<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>EnvironmentTyping.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.11.0+0.11.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Distributed under the terms of the MIT license. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Import</span> config utils BasicAst Universes Environment.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Equations <span class="kn">Require Import</span> Equations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Lookup</span> (T : Term) (E : EnvironmentSig T).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E.</span></span></span></pre><div class="doc">
<a name="lab1"></a><h2 class="section">Environment lookup</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">declared_constant</span> (<span class="nv">Œ£</span> : global_env) (<span class="nv">id</span> : kername) <span class="nv">decl</span> : <span class="kt">Prop</span> :=
    lookup_env Œ£ id = Some (ConstantDecl decl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">declared_minductive</span> <span class="nv">Œ£</span> <span class="nv">mind</span> <span class="nv">decl</span> :=
    lookup_env Œ£ mind = Some (InductiveDecl decl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">declared_inductive</span> <span class="nv">Œ£</span> <span class="nv">ind</span> <span class="nv">mdecl</span> <span class="nv">decl</span> :=
    declared_minductive Œ£ (inductive_mind ind) mdecl /\
    List.nth_error mdecl.(ind_bodies) (inductive_ind ind) = Some decl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">declared_constructor</span> <span class="nv">Œ£</span> <span class="nv">cstr</span> <span class="nv">mdecl</span> <span class="nv">idecl</span> <span class="nv">cdecl</span> : <span class="kt">Prop</span> :=
    declared_inductive Œ£ (fst cstr) mdecl idecl /\
    List.nth_error idecl.(ind_ctors) (snd cstr) = Some cdecl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">declared_projection</span> <span class="nv">Œ£</span> (<span class="nv">proj</span> : projection) <span class="nv">mdecl</span> <span class="nv">idecl</span> <span class="nv">pdecl</span>
  : <span class="kt">Prop</span> :=
    declared_inductive Œ£ (fst (fst proj)) mdecl idecl /\
    List.nth_error idecl.(ind_projs) (snd proj) = Some pdecl /\
    mdecl.(ind_npars) = snd (fst proj).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_udecl_decl</span> {<span class="nv">A</span>} (<span class="nv">F</span> : universes_decl -&gt; A) <span class="nv">d</span> : A :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | ConstantDecl cb =&gt; F cb.(cst_universes)
  | InductiveDecl mb =&gt; F mb.(ind_universes)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monomorphic_udecl_decl</span> := on_udecl_decl monomorphic_udecl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monomorphic_levels_decl</span> := fst ‚àò monomorphic_udecl_decl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">monomorphic_constraints_decl</span> := snd ‚àò monomorphic_udecl_decl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">universes_decl_of_decl</span> := on_udecl_decl (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abstract_instance</span> <span class="nv">decl</span> :=
    <span class="kr">match</span> decl <span class="kr">with</span>
    | Monomorphic_ctx _ =&gt; <span class="kn">Instance</span>.empty
    | Polymorphic_ctx auctx =&gt; UContext.instance (AUContext.repr auctx)
    <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* Definition LevelSet_add_list l := LevelSet.union (LevelSetProp.of_list l). *)</span>

</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_levels</span> (<span class="nv">Œ£</span> : global_env) : LevelSet.t :=
    fold_right
      (<span class="kr">fun</span> <span class="nv">decl</span> <span class="nv">lvls</span> =&gt; LevelSet.union (monomorphic_levels_decl decl.<span class="mi">2</span>) lvls)
      (LevelSet.singleton (Level.lSet)) Œ£.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">global_levels_Set</span> <span class="nv">Œ£</span> :
    LevelSet.mem Level.lSet (global_levels Œ£) = true.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LevelSet.mem Level.lSet (global_levels Œ£) = true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LevelSet.mem Level.lSet (global_levels Œ£) = true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2"><span class="highlight"><span class="nb">induction</span> Œ£; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LevelSet.mem Level.lSet
  (LevelSet.singleton Level.lSet) = true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername * global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (kername √ó global_decl)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.mem Level.lSet (global_levels Œ£) = true</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk3"><hr></label><div class="goal-conclusion"><span class="highlight">LevelSet.mem Level.lSet
  (LevelSet.union (monomorphic_levels_decl a.<span class="mi">2</span>)
     (global_levels Œ£)) = true</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4"><span class="highlight"><span class="bp">reflexivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername * global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (kername √ó global_decl)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.mem Level.lSet (global_levels Œ£) = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LevelSet.mem Level.lSet
  (LevelSet.union (monomorphic_levels_decl a.<span class="mi">2</span>)
     (global_levels Œ£)) = true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5"><span class="highlight"><span class="nb">apply</span> LevelSet.mem_spec, LevelSet.union_spec; <span class="nb">right</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername * global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (kername √ó global_decl)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.mem Level.lSet (global_levels Œ£) = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LevelSet.In Level.lSet (global_levels Œ£)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> LevelSet.mem_spec <span class="kr">in</span> IHŒ£.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
One can compute the constraints associated to a global environment or its
      extension by folding over its constituent definitions.

<div class="paragraph"> </div>

      We make *only* the second of these computations an implicit coercion
      for more readability. Note that <span class="inlinecode"><span class="id" title="var">fst_ctx</span></span> is also a coercion which goes
      from a <span class="inlinecode"><span class="id" title="var">global_env_ext</span></span> to a <span class="inlinecode"><span class="id" title="var">global_env</span></span>: coercion coherence would *not*
      be ensured if we added <span class="inlinecode"><span class="id" title="var">global_constraints</span></span> as well as a coercion, as it
      would forget the extension's constraints. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_constraints</span> (<span class="nv">Œ£</span> : global_env) : ConstraintSet.t :=
    fold_right (<span class="kr">fun</span> <span class="nv">decl</span> <span class="nv">ctrs</span> =&gt;
        ConstraintSet.union (monomorphic_constraints_decl decl.<span class="mi">2</span>) ctrs
      ) ConstraintSet.empty Œ£.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_uctx</span> (<span class="nv">Œ£</span> : global_env) : ContextSet.t :=
    (global_levels Œ£, global_constraints Œ£).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_ext_levels</span> (<span class="nv">Œ£</span> : global_env_ext) : LevelSet.t :=
    LevelSet.union (levels_of_udecl (snd Œ£)) (global_levels Œ£.<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_ext_constraints</span> (<span class="nv">Œ£</span> : global_env_ext) : ConstraintSet.t :=
    ConstraintSet.union
      (constraints_of_udecl (snd Œ£))
      (global_constraints Œ£.<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">global_ext_constraints</span> : global_env_ext &gt;-&gt; ConstraintSet.t.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">global_ext_uctx</span> (<span class="nv">Œ£</span> : global_env_ext) : ContextSet.t :=
    (global_ext_levels Œ£, global_ext_constraints Œ£).</span></span></span></pre><div class="doc">
Check that <span class="inlinecode"><span class="id" title="var">uctx</span></span> instantiated at <span class="inlinecode"><span class="id" title="var">u</span></span> is consistent with
    the current universe graph. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">consistent_instance</span> `{checker_flags} (lvs : LevelSet.t) (œÜ : ConstraintSet.t) uctx (u : <span class="kn">Instance</span>.t) :=
    <span class="kr">match</span> uctx <span class="kr">with</span>
    | Monomorphic_ctx c =&gt; List.length u = <span class="mi">0</span>
    | Polymorphic_ctx c =&gt;
      <span class="c">(* levels of the instance already declared *)</span>
      forallb (<span class="kr">fun</span> <span class="nv">l</span> =&gt; LevelSet.mem l lvs) u /\
      List.length u = List.length c.<span class="mi">1</span> /\
      valid_constraints œÜ (subst_instance_cstrs u c.<span class="mi">2</span>)
    <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">consistent_instance_ext</span> `{checker_flags} Œ£ :=
    consistent_instance (global_ext_levels Œ£) (global_ext_constraints Œ£).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Lookup</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">LookupSig</span> (T : Term) (E : EnvironmentSig T).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Include</span> Lookup T E.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">LookupSig</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">EnvTyping</span> (T : Term) (E : EnvironmentSig T).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">TypeLocal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">typing</span> : <span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>), term -&gt; option term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">All_local_env</span> : <span class="kp">context</span> -&gt; <span class="kt">Type</span> :=
    | localenv_nil :
        All_local_env []

    | localenv_cons_abs Œì na t :
        All_local_env Œì -&gt;
        typing Œì t None -&gt;
        All_local_env (Œì ,, vass na t)

    | localenv_cons_def Œì na b t :
        All_local_env Œì -&gt;
        typing Œì t None -&gt;
        typing Œì b (Some t) -&gt;
        All_local_env (Œì ,, vdef na b t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> NoConfusion <span class="kr">for</span> All_local_env.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">TypeLocal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> localenv_nil {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> localenv_cons_def {_ _ _ _ _} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> localenv_cons_abs {_ _ _ _} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">All_local_env_fold</span> <span class="nv">P</span> <span class="nv">f</span> <span class="nv">Œì</span> :
    All_local_env (<span class="kr">fun</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span> =&gt; P (fold_context_k f Œì) (f #|Œì| t) (option_map (f #|Œì|) T)) Œì &lt;~&gt;
    All_local_env P (fold_context_k f Œì).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì &lt;~&gt;
All_local_env P (fold_context_k f Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì &lt;~&gt;
All_local_env P (fold_context_k f Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì -&gt;
All_local_env P (fold_context_k f Œì)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk9"><hr></label><div class="goal-conclusion"><span class="highlight">All_local_env P (fold_context_k f Œì) -&gt;
All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chka"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì -&gt;
All_local_env P (fold_context_k f Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="nb">unfold</span> snoc; <span class="nb">rewrite</span> <span class="nl">?fold_context_k_snoc0</span>; <span class="kp">try</span> <span class="nb">constructor</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chkb"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P (fold_context_k f Œì) -&gt;
All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chkc"><span class="highlight"><span class="nb">induction</span> Œì; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="nb">unfold</span> snoc; <span class="nb">rewrite</span> <span class="nl">?fold_context_k_snoc0</span>; <span class="nb">intros</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P (fold_context_k f [])</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì) (f #|Œì| t)
     (option_map (f #|Œì|) T)) []</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P (fold_context_k f Œì) -&gt;
All_local_env
(<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
P (fold_context_k f Œì0) (f #|Œì0| t) (option_map (f #|Œì0|) T)) Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P
  (fold_context_k f Œì,, map_decl (f #|Œì|) a)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chkd"><hr></label><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) (a :: Œì)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chke"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P (fold_context_k f [])</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì) (f #|Œì| t)
     (option_map (f #|Œì|) T)) []</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">constructor</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chkf"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P (fold_context_k f Œì) -&gt;
All_local_env
(<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
P (fold_context_k f Œì0) (f #|Œì0| t) (option_map (f #|Œì0|) T)) Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env P
  (fold_context_k f Œì,, map_decl (f #|Œì|) a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env
  (<span class="kr">fun</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term) =&gt;
   P (fold_context_k f Œì0) (f #|Œì0| t)
     (option_map (f #|Œì0|) T)) (a :: Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [na [b|] ty]; depelim H; <span class="nb">specialize</span> (IHŒì H); <span class="nb">constructor</span>; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">All_local_env_impl_ind</span> {<span class="nv">P</span> <span class="nv">Q</span> : <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>} {<span class="nv">l</span>} :
    All_local_env P l -&gt;
    (<span class="kr">forall</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, All_local_env Q Œì -&gt; P Œì t T -&gt; Q Œì t T) -&gt;
    All_local_env Q l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P l -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 All_local_env Q Œì -&gt; P Œì t T -&gt; Q Œì t T) -&gt;
All_local_env Q l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P l -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 All_local_env Q Œì -&gt; P Œì t T -&gt; Q Œì t T) -&gt;
All_local_env Q l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">intros</span>; <span class="nb">simpl</span>; <span class="nb">econstructor</span>; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Well-formedness of local environments embeds a sorting for each variable 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift_typing</span> (<span class="nv">P</span> : global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span>) :
  (global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>) :=
    <span class="kr">fun</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span> =&gt;
      <span class="kr">match</span> T <span class="kr">with</span>
      | Some T =&gt; P Œ£ Œì t T
      | None =&gt; { s : <span class="kn">Universe</span>.t &amp; P Œ£ Œì t (tSort s) }
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_local_decl</span> (<span class="nv">P</span> : <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>) <span class="nv">Œì</span> <span class="nv">d</span> :=
    <span class="kr">match</span> d.(decl_body) <span class="kr">with</span>
    | Some b =&gt; P Œì b (Some d.(decl_type))
    | None =&gt; P Œì d.(decl_type) None
    <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">TypeLocalOver</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">typing</span> : <span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>), term -&gt; term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">property</span> : <span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>),
                All_local_env (lift_typing typing Œ£) Œì -&gt;
                <span class="kr">forall</span> (<span class="nv">t</span> <span class="nv">T</span> : term), typing Œ£ Œì t T -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">All_local_env_over</span> (<span class="nv">Œ£</span> : global_env_ext) :
      <span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>), All_local_env (lift_typing typing Œ£) Œì -&gt; <span class="kt">Type</span> :=
    | localenv_over_nil :
        All_local_env_over Œ£ [] localenv_nil

    | localenv_over_cons_abs Œì na t
        (<span class="kp">all</span> : All_local_env (lift_typing typing Œ£) Œì) :
        All_local_env_over Œ£ Œì <span class="kp">all</span> -&gt;
        <span class="kr">forall</span> (<span class="nv">tu</span> : lift_typing typing Œ£ Œì t None),
          property Œ£ Œì <span class="kp">all</span> _ _ (projT2 tu) -&gt;
          All_local_env_over Œ£ (Œì ,, vass na t)
                             (localenv_cons_abs <span class="kp">all</span> tu)

    | localenv_over_cons_def Œì na b t
        (<span class="kp">all</span> : All_local_env (lift_typing typing Œ£) Œì) (tb : typing Œ£ Œì b t) :
        All_local_env_over Œ£ Œì <span class="kp">all</span> -&gt;
        property Œ£ Œì <span class="kp">all</span> _ _ tb -&gt;
        <span class="kr">forall</span> (<span class="nv">tu</span> : lift_typing typing Œ£ Œì t None),
          property Œ£ Œì <span class="kp">all</span> _ _ (projT2 tu) -&gt;
          All_local_env_over Œ£ (Œì ,, vdef na b t)
                             (localenv_cons_def <span class="kp">all</span> tu tb).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">TypeLocalOver</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> <span class="kr">for</span> All_local_env_over.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">TypeCtxInst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">typing</span> : <span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>), term -&gt; term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
    <span class="c">(* Œì |- s : Œî, where Œî is a telescope (reverse context) *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">ctx_inst</span> <span class="nv">Œ£</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) : list term -&gt; <span class="kp">context</span> -&gt; <span class="kt">Type</span> :=
    | ctx_inst_nil : ctx_inst Œ£ Œì [] []
    | ctx_inst_ass na t i inst Œî : 
        typing Œ£ Œì i t -&gt;
        ctx_inst Œ£ Œì inst (subst_telescope [i] <span class="mi">0</span> Œî) -&gt;
        ctx_inst Œ£ Œì (i :: inst) (vass na t :: Œî)
    | ctx_inst_def na b t inst Œî :
        ctx_inst Œ£ Œì inst (subst_telescope [b] <span class="mi">0</span> Œî) -&gt;
        ctx_inst Œ£ Œì inst (vdef na b t :: Œî).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> NoConfusion <span class="kr">for</span> ctx_inst.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">TypeCtxInst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">EnvTyping</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">EnvTypingSig</span> (T : Term) (E : EnvironmentSig T).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Include</span> EnvTyping T E.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">EnvTypingSig</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">ConversionParSig</span> (T : Term) (E : EnvironmentSig T) (ET : EnvTypingSig T E).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E ET.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> (<span class="nv">conv</span> : <span class="kr">forall</span> `{checker_flags}, global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> (<span class="nv">cumul</span> : <span class="kr">forall</span> `{checker_flags}, global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ConversionParSig</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Conversion</span> (T : Term) (E : EnvironmentSig T) (ET : EnvTypingSig T E) (CT : ConversionParSig T E ET).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E ET CT.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ContextConversion</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">cf</span> : checker_flags}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">Œ£</span> : global_env_ext).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">conv_decls</span> (<span class="nv">Œì</span> <span class="nv">Œì&#39;</span> : <span class="kp">context</span>) : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : context_decl), <span class="kt">Type</span> :=
    | conv_vass na na&#39; T T&#39; :
        eq_binder_annot na na&#39; -&gt;
        conv Œ£ Œì T T&#39; -&gt;
        conv_decls Œì Œì&#39; (vass na T) (vass na&#39; T&#39;)
  
    | conv_vdef_body na na&#39; b b&#39; T T&#39; :
        eq_binder_annot na na&#39; -&gt;
        conv Œ£ Œì b b&#39; -&gt;
        conv Œ£ Œì T T&#39; -&gt;
        conv_decls Œì Œì&#39; (vdef na b T) (vdef na&#39; b&#39; T&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> NoConfusion <span class="kr">for</span> conv_decls.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">cumul_decls</span> (<span class="nv">Œì</span> <span class="nv">Œì&#39;</span> : <span class="kp">context</span>) : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : context_decl), <span class="kt">Type</span> :=
    | cumul_vass na na&#39; T T&#39; :
        eq_binder_annot na na&#39; -&gt;
        cumul Œ£ Œì T T&#39; -&gt;
        cumul_decls Œì Œì&#39; (vass na T) (vass na&#39; T&#39;)
  
    | cumul_vdef_body na na&#39; b b&#39; T T&#39; :
        eq_binder_annot na na&#39; -&gt;
        conv Œ£ Œì b b&#39; -&gt; <span class="c">(* Not that definiens must be convertible, otherwise this notion </span>
<span class="c">                            of cumulativity is useless *)</span>
        cumul Œ£ Œì T T&#39; -&gt;
        cumul_decls Œì Œì&#39; (vdef na b T) (vdef na&#39; b&#39; T&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> NoConfusion <span class="kr">for</span> cumul_decls.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ContextConversion</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cumul_ctx_rel</span> {<span class="nv">cf</span>:checker_flags} <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œî</span> <span class="nv">Œî&#39;</span> :=
    All2_fold (<span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">Œî&#39;</span> =&gt; cumul_decls Œ£ (Œì ,,, Œî) (Œì ,,, Œî&#39;)) Œî Œî&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Conversion</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">ConversionSig</span> (T : Term) (E : EnvironmentSig T) (ET : EnvTypingSig T E) (CT : ConversionParSig T E ET).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Include</span> Conversion T E ET CT.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ConversionSig</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module Type</span> <span class="nf">Typing</span> (T : Term) (E : EnvironmentSig T) (ET : EnvTypingSig T E) 
  (CS : ConversionParSig T E ET) (CT : ConversionSig T E ET CS).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E ET CS CT.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> (<span class="nv">typing</span> : <span class="kr">forall</span> `{checker_flags}, global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> (<span class="nv">wf_universe</span> : global_env_ext -&gt; Universe.t -&gt; <span class="kt">Prop</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; Œ£ ;;; Œì |- t : T &quot;</span> :=
    (typing Œ£ Œì t T) (<span class="kn">at level</span> <span class="mi">50</span>, Œì, t, T <span class="kn">at next level</span>) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">Inline</span> <span class="nv">inds</span> : kername -&gt; <span class="kn">Instance</span>.t -&gt; list one_inductive_body -&gt; list term.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Parameter</span> <span class="nv">destArity</span> : term -&gt; option (<span class="kp">context</span> * <span class="kn">Universe</span>.t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">wf_local</span> Œ£ Œì := (All_local_env (lift_typing typing Œ£) Œì).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Typing</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">DeclarationTyping</span> (T : Term) (E : EnvironmentSig T)
  (ET : EnvTypingSig T E) 
  (CS : ConversionParSig T E ET)
  (CT : ConversionSig T E ET CS) (Ty : Typing T E ET CS CT) 
  (L : LookupSig T E).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> T E Ty L ET CS CT.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isType</span> `{checker_flags} (Œ£ : global_env_ext) (Œì : <span class="kp">context</span>) (t : term) :=
    { s : _ &amp; Œ£ ;;; Œì |- t : tSort s }.</span></span></span></pre><div class="doc">
<a name="lab2"></a><h3 class="section">Typing of inductive declarations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">GlobalMaps</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">cf</span>: checker_flags}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">P</span> : global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_context</span> <span class="nv">Œ£</span> <span class="nv">ctx</span> :=
      All_local_env (P Œ£) ctx.</span></span></span></pre><div class="doc">
For well-formedness of inductive declarations we need a way to check that a assumptions
      of a given context is typable in a sort <span class="inlinecode"><span class="id" title="var">u</span></span>. We also force well-typing of the let-ins
      in any universe to imply wf_local. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">type_local_ctx</span> <span class="nv">Œ£</span> (<span class="nv">Œì</span> <span class="nv">Œî</span> : <span class="kp">context</span>) (<span class="nv">u</span> : Universe.t) : <span class="kt">Type</span> :=
      <span class="kr">match</span> Œî <span class="kr">with</span>
      | [] =&gt; wf_universe Œ£ u
      | {| decl_body := None; decl_type := t |} :: Œî =&gt; (type_local_ctx Œ£ Œì Œî u * (P Œ£ (Œì ,,, Œî) t (Some (tSort u))))
      | {| decl_body := Some b; decl_type := t |} :: Œî =&gt; (type_local_ctx Œ£ Œì Œî u * (P Œ£ (Œì ,,, Œî) t None * P Œ£ (Œì ,,, Œî) b (Some t)))
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">sorts_local_ctx</span> <span class="nv">Œ£</span> (<span class="nv">Œì</span> <span class="nv">Œî</span> : <span class="kp">context</span>) (<span class="nv">us</span> : list Universe.t) : <span class="kt">Type</span> :=
      <span class="kr">match</span> Œî, us <span class="kr">with</span>
      | [], [] =&gt; unit
      | {| decl_body := None; decl_type := t |} :: Œî, u :: us =&gt; 
        (sorts_local_ctx Œ£ Œì Œî us * (P Œ£ (Œì ,,, Œî) t (Some (tSort u))))
      | {| decl_body := Some b; decl_type := t |} :: Œî, us =&gt; 
        (sorts_local_ctx Œ£ Œì Œî us * (P Œ£ (Œì ,,, Œî) t None * P Œ£ (Œì ,,, Œî) b (Some t)))
      | _, _ =&gt; <span class="kt">False</span>
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Implicit Types</span> (<span class="nv">mdecl</span> : mutual_inductive_body) (<span class="nv">idecl</span> : one_inductive_body) (<span class="nv">cdecl</span> : constructor_body).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_type</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">T</span> := P Œ£ Œì T None.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Open Scope</span> type_scope.</span></span></span></pre><div class="doc">
Positivity checking of the inductive, ensuring that the inductive itself 
      can only appear at the right of an arrow in each argument's types. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    <span class="c">(*</span>
<span class="c">    Definition positive_cstr_arg ninds npars narg (arg : term) : bool :=</span>
<span class="c">      (* We decompose the constructor&#39;s arguments&#39; type and verify the inductive references</span>
<span class="c">        only appear in the conclusion, if any. *)</span>
<span class="c">      let (ctx, concl) := decompose_prod_assum [] arg in</span>
<span class="c">      (* Again, we smash the context, as Coq does *)</span>
<span class="c">      let ctx := smash_context [] ctx in</span>
<span class="c">      alli (fun i d =&gt; noccur_between (npars + narg + i) ninds d.(decl_type)) 0 (List.rev ctx) &amp;&amp;</span>
<span class="c">      let (hd, args) := decompose_app concl in</span>
<span class="c">      match hd with</span>
<span class="c">      | tRel i =&gt; </span>
<span class="c">        if noccur_between (npars + narg + #|ctx|) ninds (tRel i) then </span>
<span class="c">          (* Call to an unrelated variable *)</span>
<span class="c">          true</span>
<span class="c">        else (* Recursive call to the inductive *)</span>
<span class="c">          (* Coq disallows the inductive to be applied to another inductive in the block *)</span>
<span class="c">          forallb (noccur_between (npars + narg + #|ctx|) ninds) args</span>
<span class="c">      | tInd ind u =&gt; </span>
<span class="c">        if forallb (noccur_between (npars + narg + #|ctx|) ninds) args then</span>
<span class="c">          (* Unrelated inductive *)</span>
<span class="c">          true</span>
<span class="c">        else (* Nested inductive *)</span>
<span class="c">          true</span>
<span class="c">      end.</span>

<span class="c">    Definition positive_cstr_args ninds npars (args : context) : bool :=</span>
<span class="c">      alli (fun i decl =&gt; positive_cstr_arg nind npars i decl.(decl_type))</span>
<span class="c">      (* We smash the context, just as Coq&#39;s kernel computes positivity on </span>
<span class="c">        weak-head normalized types *)</span>
<span class="c">      (List.rev (smash_context [] args))</span>
<span class="c">    *)</span></span></span></pre><div class="doc">
A constructor argument type <span class="inlinecode"><span class="id" title="var">t</span></span> is positive w.r.t. an inductive block <span class="inlinecode"><span class="id" title="var">mdecl</span></span>
      when it's zeta-normal form is of the shape Œ† Œî. concl and: 
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">t</span></span> does not refer to any inductive in the block.
          In that case <span class="inlinecode"><span class="id" title="var">t</span></span> must be a closed type under the context of parameters and
          previous arguments.

</li>
<li> None of the variable assumptions in Œî refer to any inductive in the block, 
          but the conclusion <span class="inlinecode"><span class="id" title="var">concl</span></span> is of the form <span class="inlinecode"><span class="id" title="var">mkApps</span></span> <span class="inlinecode">(<span class="id" title="var">tRel</span></span> <span class="inlinecode"><span class="id" title="var">k</span>)</span> <span class="inlinecode"><span class="id" title="var">args</span></span> for k 
          refering to an inductive in the block, and none of the arguments <span class="inlinecode"><span class="id" title="var">args</span></span>
          refer to the inductive. |args| must be the length of the full inductive application.         
      
      Let-in assumptions in Œî are systematically unfolded, i.e. we really consider:
      the zeta-reduction of [t]. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ind_realargs</span> (<span class="nv">o</span> : one_inductive_body) := 
      <span class="kr">match</span> destArity o.(ind_type) <span class="kr">with</span>
      | Some (ctx, _) =&gt; #|smash_context [] ctx|
      | _ =&gt; <span class="mi">0</span>
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">positive_cstr_arg</span> <span class="nv">mdecl</span> <span class="nv">ctx</span> : term -&gt; <span class="kt">Type</span> :=
    | positive_cstr_arg_closed t : 
      closedn #|ctx| t -&gt;
      positive_cstr_arg mdecl ctx t

    | positive_cstr_arg_concl l k i : 
      <span class="sd">(** Mutual inductive references in the conclusion are ok *)</span>
      #|ctx| &lt;= k -&gt; k &lt; #|ctx| + #|mdecl.(ind_bodies)| -&gt;
      All (closedn #|ctx|) l -&gt;
      nth_error (List.rev mdecl.(ind_bodies)) (k - #|ctx|) = Some i -&gt;
      #|l| = ind_realargs i -&gt;
      positive_cstr_arg mdecl ctx (mkApps (tRel k) l)

    | positive_cstr_arg_let na b ty t :
      positive_cstr_arg mdecl ctx (<span class="nb">subst</span> [b] <span class="mi">0</span> t) -&gt;
      positive_cstr_arg mdecl ctx (tLetIn na b ty t) 

    | positive_cstr_arg_ass na ty t :
      closedn #|ctx| ty -&gt;
      positive_cstr_arg mdecl (vass na ty :: ctx) t -&gt;
      positive_cstr_arg mdecl ctx (tProd na ty t).</span></span></span></pre><div class="doc">
A constructor type <span class="inlinecode"><span class="id" title="var">t</span></span> is positive w.r.t. an inductive block <span class="inlinecode"><span class="id" title="var">mdecl</span></span>
      and inductive <span class="inlinecode"><span class="id" title="var">i</span></span> when it's zeta normal-form is of the shape Œ† Œî. concl and: 
<ul class="doclist">
<li> All of the arguments in Œî are positive.

</li>
<li> The conclusion is of the shape <span class="inlinecode"><span class="id" title="var">mkApps</span></span> <span class="inlinecode">(<span class="id" title="var">tRel</span></span> <span class="inlinecode"><span class="id" title="var">k</span>)</span> <span class="inlinecode"><span class="id" title="var">indices</span></span> 
          where <span class="inlinecode"><span class="id" title="var">k</span></span> refers to the current inductive <span class="inlinecode"><span class="id" title="var">i</span></span> and <span class="inlinecode"><span class="id" title="var">indices</span></span> does not mention
          any of the inductive types in the block. I.e. <span class="inlinecode"><span class="id" title="var">indices</span></span> are closed terms
          in <span class="inlinecode"><span class="id" title="var">params</span></span> <span class="inlinecode">,,,</span> <span class="inlinecode"><span class="id" title="var">args</span></span>. 
</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">positive_cstr</span> <span class="nv">mdecl</span> <span class="nv">i</span> (<span class="nv">ctx</span> : <span class="kp">context</span>) : term -&gt; <span class="kt">Type</span> :=
    | positive_cstr_concl indices :
      <span class="kr">let</span> <span class="nv">headrel</span> : nat := 
        (#|mdecl.(ind_bodies)| - S i + #|ctx|)%nat <span class="kr">in</span>
      All (closedn #|ctx|) indices -&gt;
      positive_cstr mdecl i ctx (mkApps (tRel headrel) indices)

    | positive_cstr_let na b ty t :
      positive_cstr mdecl i ctx (<span class="nb">subst</span> [b] <span class="mi">0</span> t) -&gt;
      positive_cstr mdecl i ctx (tLetIn na b ty t) 

    | positive_cstr_ass na ty t :
      positive_cstr_arg mdecl ctx ty -&gt;
      positive_cstr mdecl i (vass na ty :: ctx) t -&gt;
      positive_cstr mdecl i ctx (tProd na ty t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift_level</span> <span class="nv">n</span> <span class="nv">l</span> :=
      <span class="kr">match</span> l <span class="kr">with</span> 
      | Level.lSet | Level.Level _ =&gt; l
      | Level.Var k =&gt; Level.Var (n + k)
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift_instance</span> <span class="nv">n</span> <span class="nv">l</span> :=
      map (lift_level n) l.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift_constraint</span> <span class="nv">n</span> (<span class="nv">c</span> : Level.t * ConstraintType.t * Level.t) :=
      <span class="kr">let</span> &#39;((l, r), l&#39;) := c <span class="kr">in</span>
      ((lift_level n l, r), lift_level n l&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift_constraints</span> <span class="nv">n</span> <span class="nv">cstrs</span> :=
      ConstraintSet.<span class="nb">fold</span> (<span class="kr">fun</span> <span class="nv">elt</span> <span class="nv">acc</span> =&gt; ConstraintSet.add (lift_constraint n elt) acc)
        cstrs ConstraintSet.empty.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">level_var_instance</span> <span class="nv">n</span> (<span class="nv">inst</span> : list name) :=
      mapi_rec (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">_</span> =&gt; Level.Var i) inst n.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">variance_cstrs</span> (<span class="nv">v</span> : list Variance.t) (<span class="nv">u</span> <span class="nv">u&#39;</span> : Instance.t) :=
      <span class="kr">match</span> v, u, u&#39; <span class="kr">with</span>
      | _, [], [] =&gt; ConstraintSet.empty
      | v :: vs, u :: us, u&#39; :: us&#39; =&gt; 
        <span class="kr">match</span> v <span class="kr">with</span>
        | Variance.Irrelevant =&gt; variance_cstrs vs us us&#39;
        | Variance.Covariant =&gt; ConstraintSet.add (u, ConstraintType.Le <span class="mi">0</span>, u&#39;) (variance_cstrs vs us us&#39;)
        | Variance.Invariant =&gt; ConstraintSet.add (u, ConstraintType.Eq, u&#39;) (variance_cstrs vs us us&#39;)
        <span class="kr">end</span>
      | _, _, _ =&gt; <span class="c">(* Impossible due to on_variance invariant *)</span> ConstraintSet.empty
      <span class="kr">end</span>.</span></span></span></pre><div class="doc">
This constructs a duplication of the polymorphic universe context of the inductive,  
      where the two instances are additionally related according to the variance information.
    
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">variance_universes</span> <span class="nv">univs</span> <span class="nv">v</span> :=
      <span class="kr">match</span> univs <span class="kr">with</span>
      | Monomorphic_ctx ctx =&gt; None
      | Polymorphic_ctx auctx =&gt;
        <span class="kr">let</span> (<span class="nv">inst</span>, cstrs) := auctx <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">u&#39;</span> := level_var_instance <span class="mi">0</span> inst <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">u</span> := lift_instance #|inst| u&#39; <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">cstrs</span> := ConstraintSet.union cstrs (lift_constraints #|inst| cstrs) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">cstrv</span> := variance_cstrs v u u&#39; <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">auctx&#39;</span> := (inst ++ inst, ConstraintSet.union cstrs cstrv) <span class="kr">in</span>
        Some (Polymorphic_ctx auctx&#39;, u, u&#39;)
      <span class="kr">end</span>.</span></span></span></pre><div class="doc">
A constructor type respects the given variance <span class="inlinecode"><span class="id" title="var">v</span></span> if each constructor 
        argument respects it and each index (in the conclusion) does as well.
        We formalize this by asking for a cumulativity relation between the contexts
        of arguments and conversion of the lists of indices instanciated with <span class="inlinecode"><span class="id" title="var">u</span></span> and 
        <span class="inlinecode"><span class="id" title="var">u'</span></span> where <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">`<span class="id" title="var">v</span>`</span> <span class="inlinecode"><span class="id" title="var">u'</span></span>. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ind_arities</span> <span class="nv">mdecl</span> := arities_context (ind_bodies mdecl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ind_respects_variance</span> <span class="nv">Œ£</span> <span class="nv">mdecl</span> <span class="nv">v</span> <span class="nv">indices</span> :=
      <span class="kr">let</span> <span class="nv">univs</span> := ind_universes mdecl <span class="kr">in</span>
      <span class="kr">match</span> variance_universes univs v <span class="kr">with</span>
      | Some (univs, u, u&#39;) =&gt;
        cumul_ctx_rel (Œ£, univs) (subst_instance u (smash_context [] (ind_params mdecl)))
          (subst_instance u (expand_lets_ctx (ind_params mdecl) (smash_context [] indices)))
          (subst_instance u&#39; (expand_lets_ctx (ind_params mdecl) (smash_context [] indices)))
      | None =&gt; <span class="kt">False</span>
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cstr_respects_variance</span> <span class="nv">Œ£</span> <span class="nv">mdecl</span> <span class="nv">v</span> <span class="nv">cs</span> :=
      <span class="kr">let</span> <span class="nv">univs</span> := ind_universes mdecl <span class="kr">in</span>
      <span class="kr">match</span> variance_universes univs v <span class="kr">with</span>
      | Some (univs, u, u&#39;) =&gt;
        cumul_ctx_rel (Œ£, univs) (subst_instance u (ind_arities mdecl ,,, smash_context [] (ind_params mdecl)))
          (subst_instance u (expand_lets_ctx (ind_params mdecl) (smash_context [] (cstr_args cs))))
          (subst_instance u&#39; (expand_lets_ctx (ind_params mdecl) (smash_context [] (cstr_args cs)))) *
        All2 
          (conv (Œ£, univs) (subst_instance u (ind_arities mdecl ,,, smash_context [] (ind_params mdecl ,,, cstr_args cs))))
          (map (subst_instance u ‚àò expand_lets (ind_params mdecl ,,, cstr_args cs)) (cstr_indices cs))
          (map (subst_instance u&#39; ‚àò expand_lets (ind_params mdecl ,,, cstr_args cs)) (cstr_indices cs))
      | None =&gt; <span class="kt">False</span> <span class="c">(* Monomorphic inductives have no variance attached *)</span>
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
    <span class="c">(* Conclusion head: reference to the current inductive in the block *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cstr_concl_head</span> <span class="nv">mdecl</span> <span class="nv">i</span> <span class="nv">idecl</span> <span class="nv">cdecl</span> :=
      tRel (#|mdecl.(ind_bodies)| - S i + #|mdecl.(ind_params)| + #|cstr_args cdecl|).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
    <span class="c">(* Constructor conclusion shape: the inductives type applied to variables for</span>
<span class="c">       the (non-let) parameters </span>
<span class="c">       followed by the indices *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cstr_concl</span> <span class="nv">mdecl</span> <span class="nv">i</span> <span class="nv">idecl</span> <span class="nv">cdecl</span> :=
      (mkApps (cstr_concl_head mdecl i idecl cdecl)
        (to_extended_list_k mdecl.(ind_params) #|cstr_args cdecl|
          ++ cstr_indices cdecl)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">on_constructor</span> <span class="nv">Œ£</span> <span class="nv">mdecl</span> <span class="nv">i</span> <span class="nv">idecl</span> <span class="nv">ind_indices</span> <span class="nv">cdecl</span> <span class="nv">cunivs</span> := {
      <span class="c">(* cdecl.1 fresh ?? *)</span>
      cstr_args_length : context_assumptions (cstr_args cdecl) = cstr_arity cdecl;

      cstr_eq : cstr_type cdecl =
       it_mkProd_or_LetIn mdecl.(ind_params) 
        (it_mkProd_or_LetIn (cstr_args cdecl) 
          (cstr_concl mdecl i idecl cdecl));
      <span class="c">(* The type of the constructor canonically has this shape: parameters, real</span>
<span class="c">        arguments ending with a reference to the inductive applied to the</span>
<span class="c">        (non-lets) parameters and arguments *)</span>

      on_ctype : on_type Œ£ (arities_context mdecl.(ind_bodies)) (cstr_type cdecl);
      on_cargs :
        sorts_local_ctx Œ£ (arities_context mdecl.(ind_bodies) ,,, mdecl.(ind_params))
                      cdecl.(cstr_args) cunivs;
      on_cindices : 
        ctx_inst (<span class="kr">fun</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span> =&gt; P Œ£ Œì t (Some T)) Œ£ (arities_context mdecl.(ind_bodies) ,,, mdecl.(ind_params) ,,, cdecl.(cstr_args))
                      cdecl.(cstr_indices)
                      (List.rev (lift_context #|cdecl.(cstr_args)| <span class="mi">0</span> ind_indices));

      on_ctype_positive : <span class="c">(* The constructor type is positive *)</span>
        positive_cstr mdecl i [] (cstr_type cdecl);

      on_ctype_variance : <span class="c">(* The constructor type respect the variance annotation </span>
<span class="c">        on polymorphic universes, if any. *)</span>
        <span class="kr">forall</span> <span class="nv">v</span>, ind_variance mdecl = Some v -&gt; 
        cstr_respects_variance Œ£ mdecl v cdecl
    }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_ctype {Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_cargs {Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_cindices {Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cstr_args_length {Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cstr_eq {Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_constructors</span> <span class="nv">Œ£</span> <span class="nv">mdecl</span> <span class="nv">i</span> <span class="nv">idecl</span> <span class="nv">ind_indices</span> :=
      All2 (on_constructor Œ£ mdecl i idecl ind_indices).</span></span></span></pre><div class="doc">
Each projection type corresponds to a non-let argument of the 
        corresponding constructor. It is parameterized over the 
        parameters of the inductive type and all the preceding arguments
        of the constructor. When computing the type of a projection for argument
        <span class="inlinecode"><span class="id" title="var">n</span></span> at a given instance of the parameters and a given term <span class="inlinecode"><span class="id" title="var">t</span></span> in the inductive
        type, we instantiate the argument context by corresponsping projections
        <span class="inlinecode"><span class="id" title="var">t</span>.œÄ1</span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">t</span>.œÄ<span class="id" title="var">n</span>-1</span>. This is essential for subject reduction to hold: each
        projections type can only refer to the record object through projections.

<div class="paragraph"> </div>

      Projection types have their parameter and argument contexts smashed to avoid
      costly computations during type-checking and reduction: we can just substitute
      the instances of parameters and the inductive value without considering the 
      presence of let bindings. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">projs</span> <span class="nv">ind</span> <span class="nv">npars</span> <span class="nv">k</span> :=
      <span class="kr">match</span> k <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; []
      | S k&#39; =&gt; (tProj ((ind, npars), k&#39;) (tRel <span class="mi">0</span>)) :: projs ind npars k&#39;
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk12"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">projs_length</span> <span class="nv">ind</span> <span class="nv">npars</span> <span class="nv">k</span> : #|projs ind npars k| = k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">cf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">npars, k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|projs ind npars k| = k</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk13"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">cf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">npars, k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|projs ind npars k| = k</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> k; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_projection</span> <span class="nv">mdecl</span> <span class="nv">mind</span> <span class="nv">i</span> <span class="nv">cdecl</span> (<span class="nv">k</span> : nat) (<span class="nv">p</span> : ident * term) :=
      <span class="kr">let</span> <span class="nv">Œì</span> := smash_context [] (cdecl.(cstr_args) ++ mdecl.(ind_params)) <span class="kr">in</span>
      <span class="kr">match</span> nth_error Œì (context_assumptions cdecl.(cstr_args) - S k) <span class="kr">with</span>
      | None =&gt; <span class="kt">False</span>
      | Some decl =&gt; 
        <span class="kr">let</span> <span class="nv">u</span> := abstract_instance mdecl.(ind_universes) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">ind</span> := {| inductive_mind := mind; inductive_ind := i |} <span class="kr">in</span>
        <span class="sd">(** The stored projection type already has the references to the inductive</span>
<span class="sd">          type substituted along with the previous arguments replaced by projections.</span>
<span class="sd">          All projections must also be named.</span>
<span class="sd">          *)</span>
        (binder_name (decl_name decl) = nNamed (fst p)) /\
        (snd p = <span class="nb">subst</span> (inds mind u mdecl.(ind_bodies)) (S (ind_npars mdecl))
              (<span class="nb">subst</span> (projs ind mdecl.(ind_npars) k) <span class="mi">0</span> 
                (lift <span class="mi">1</span> k (decl_type decl))))
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">on_projections</span> <span class="nv">mdecl</span> <span class="nv">mind</span> <span class="nv">i</span> <span class="nv">idecl</span> (<span class="nv">ind_indices</span> : <span class="kp">context</span>) <span class="nv">cdecl</span> :=
      { on_projs_record : #|idecl.(ind_ctors)| = <span class="mi">1</span>;
        <span class="sd">(** The inductive must be a record *)</span>

        on_projs_noidx : #|ind_indices| = <span class="mi">0</span>;
        <span class="sd">(** The inductive cannot have indices *)</span>

        on_projs_elim : idecl.(ind_kelim) = IntoAny;
        <span class="sd">(** This ensures that all projections are definable *)</span>

        on_projs_all : #|idecl.(ind_projs)| = context_assumptions (cstr_args cdecl);
        <span class="sd">(** There are as many projections as (non-let) constructor arguments *)</span>

        on_projs : Alli (on_projection mdecl mind i cdecl) <span class="mi">0</span> idecl.(ind_projs) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">check_constructors_smaller</span> <span class="nv">œÜ</span> <span class="nv">cunivss</span> <span class="nv">ind_sort</span> :=
      Forall (<span class="kr">fun</span> <span class="nv">cunivs</span> =&gt; 
        Forall (<span class="kr">fun</span> <span class="nv">argsort</span> =&gt; leq_universe œÜ argsort ind_sort) cunivs) cunivss.</span></span></span></pre><div class="doc">
This ensures that all sorts in kelim are lower
        or equal to the top elimination sort, if set.
        For inductives in Type we do not check <span class="inlinecode"><span class="id" title="var">kelim</span></span> currently. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">constructor_univs</span> := list <span class="kn">Universe</span>.t.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* The sorts of the arguments context (without lets) *)</span>

</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">elim_sort_prop_ind</span> (<span class="nv">ind_ctors_sort</span> : list constructor_univs) :=
      <span class="kr">match</span> ind_ctors_sort <span class="kr">with</span>
      | [] =&gt; <span class="c">(* Empty inductive proposition: *)</span> IntoAny
      | [ s ] =&gt;
        <span class="kr">if</span> forallb Universes.is_propositional s <span class="kr">then</span>
          IntoAny <span class="c">(* Singleton elimination *)</span>
        <span class="kr">else</span>
          IntoPropSProp <span class="c">(* Squashed: some arguments are higher than Prop, restrict to Prop *)</span>
      | _ =&gt; <span class="c">(* Squashed: at least 2 constructors *)</span> IntoPropSProp
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">elim_sort_sprop_ind</span> (<span class="nv">ind_ctors_sort</span> : list constructor_univs) :=
      <span class="kr">match</span> ind_ctors_sort <span class="kr">with</span>
      | [] =&gt; <span class="c">(* Empty inductive strict proposition: *)</span> IntoAny
      | _ =&gt; <span class="c">(* All other inductives in SProp are squashed *)</span> IntoSProp
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">check_ind_sorts</span> (<span class="nv">Œ£</span> : global_env_ext)
              <span class="nv">params</span> <span class="nv">kelim</span> <span class="nv">ind_indices</span> <span class="nv">cdecls</span> <span class="nv">ind_sort</span> : <span class="kt">Type</span> :=
      <span class="kr">if</span> <span class="kn">Universe</span>.is_prop ind_sort <span class="kr">then</span>
        <span class="sd">(** The inductive is declared in the impredicative sort Prop *)</span>
        <span class="sd">(** No universe-checking to do: any size of constructor argument is allowed,</span>
<span class="sd">            however elimination restrictions apply. *)</span>
        allowed_eliminations_subset kelim (elim_sort_prop_ind cdecls)
      <span class="kr">else</span> <span class="kr">if</span> <span class="kn">Universe</span>.is_sprop ind_sort <span class="kr">then</span>
        <span class="sd">(** The inductive is declared in the impredicative sort SProp *)</span>
        <span class="sd">(** No universe-checking to do: any size of constructor argument is allowed,</span>
<span class="sd">            however elimination restrictions apply. *)</span>
        allowed_eliminations_subset kelim (elim_sort_sprop_ind cdecls)
      <span class="kr">else</span>
        <span class="sd">(** The inductive is predicative: check that all constructors arguments are</span>
<span class="sd">            smaller than the declared universe. *)</span>
        check_constructors_smaller Œ£ cdecls ind_sort
        √ó <span class="kr">if</span> indices_matter <span class="kr">then</span>
            type_local_ctx Œ£ params ind_indices ind_sort
          <span class="kr">else</span> <span class="kt">True</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">on_ind_body</span> <span class="nv">Œ£</span> <span class="nv">mind</span> <span class="nv">mdecl</span> <span class="nv">i</span> <span class="nv">idecl</span> :=
      { <span class="sd">(** The type of the inductive must be an arity, sharing the same params</span>
<span class="sd">            as the rest of the block, and maybe having a context of indices. *)</span>
        ind_arity_eq : idecl.(ind_type)
                      = it_mkProd_or_LetIn mdecl.(ind_params)
                                (it_mkProd_or_LetIn idecl.(ind_indices) (tSort idecl.(ind_sort)));

        <span class="sd">(** It must be well-typed in the empty context. *)</span>
        onArity : on_type Œ£ [] idecl.(ind_type);

        <span class="sd">(** The sorts of the arguments contexts of each constructor *)</span>
        ind_cunivs : list constructor_univs;

        <span class="sd">(** Constructors are well-typed *)</span>
        onConstructors :
          on_constructors Œ£ mdecl i idecl idecl.(ind_indices) idecl.(ind_ctors) ind_cunivs;

        <span class="sd">(** Projections, if any, are well-typed *)</span>
        onProjections :
          idecl.(ind_projs) &lt;&gt; [] -&gt;
          <span class="kr">match</span> idecl.(ind_ctors) <span class="kr">return</span> <span class="kt">Type</span> <span class="kr">with</span>
          | [ o ] =&gt;
            on_projections mdecl mind i idecl idecl.(ind_indices) o
          | _ =&gt; <span class="kt">False</span>
          <span class="kr">end</span>;

        <span class="sd">(** The universes and elimination sorts must be correct w.r.t.</span>
<span class="sd">            the universe of the inductive and the universes in its constructors, which</span>
<span class="sd">            are declared in [on_constructors]. *)</span>
        ind_sorts :
          check_ind_sorts Œ£ mdecl.(ind_params) idecl.(ind_kelim)
                          idecl.(ind_indices) ind_cunivs idecl.(ind_sort);

        onIndices : 
          <span class="c">(* The inductive type respect the variance annotation  on polymorphic universes, if any. *)</span>
          <span class="kr">forall</span> <span class="nv">v</span>, ind_variance mdecl = Some v -&gt; 
          ind_respects_variance Œ£ mdecl v idecl.(ind_indices)
      }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_variance</span> <span class="nv">univs</span> (<span class="nv">variances</span> : option (list Variance.t)) :=
      <span class="kr">match</span> univs <span class="kr">with</span>
      | Monomorphic_ctx _ =&gt; variances = None
      | Polymorphic_ctx auctx =&gt; 
        <span class="kr">match</span> variances <span class="kr">with</span>
        | None =&gt; <span class="kt">True</span>
        | Some v =&gt; List.length v = #|UContext.instance (AUContext.repr auctx)|
        <span class="kr">end</span>
      <span class="kr">end</span>.</span></span></span></pre><div class="doc">
We allow empty blocks for simplicity
        (no well-typed reference to them can be made). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">on_inductive</span> <span class="nv">Œ£</span> <span class="nv">mind</span> <span class="nv">mdecl</span> :=
      { onInductives : Alli (on_ind_body Œ£ mind mdecl) <span class="mi">0</span> mdecl.(ind_bodies);
        <span class="sd">(** We check that the context of parameters is well-formed and that</span>
<span class="sd">            the size annotation counts assumptions only (no let-ins). *)</span>
        onParams : on_context Œ£ mdecl.(ind_params);
        onNpars : context_assumptions mdecl.(ind_params) = mdecl.(ind_npars);
        onVariance : on_variance mdecl.(ind_universes) mdecl.(ind_variance);
      }.</span></span></span></pre><div class="doc">
<a name="lab3"></a><h3 class="section">Typing of constant declarations</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_constant_decl</span> <span class="nv">Œ£</span> <span class="nv">d</span> :=
      <span class="kr">match</span> d.(cst_body) <span class="kr">with</span>
      | Some trm =&gt; P Œ£ [] trm (Some d.(cst_type))
      | None =&gt; on_type Œ£ [] d.(cst_type)
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_global_decl</span> <span class="nv">Œ£</span> <span class="nv">kn</span> <span class="nv">decl</span> :=
      <span class="kr">match</span> decl <span class="kr">with</span>
      | ConstantDecl d =&gt; on_constant_decl Œ£ d
      | InductiveDecl inds =&gt; on_inductive Œ£ kn inds
      <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab4"></a><h3 class="section">Typing of global environment</h3>
<div class="paragraph"> </div>

        All declarations should be typeable and the global
        set of universe constraints should be consistent. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span></pre><div class="doc">
Well-formed global environments have no name clash. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">    </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fresh_global</span> (<span class="nv">s</span> : kername) : global_env -&gt; <span class="kt">Prop</span> :=
      Forall (<span class="kr">fun</span> <span class="nv">g</span> =&gt; g.<span class="mi">1</span> &lt;&gt; s).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">satisfiable_udecl</span> `{checker_flags} Œ£ œÜ
      := consistent (global_ext_constraints (Œ£, œÜ)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
    <span class="c">(* Check that: *)</span>
    <span class="c">(*   - declared levels are fresh *)</span>
    <span class="c">(*   - all levels used in constraints are declared *)</span>
    <span class="c">(*   - level used in monomorphic contexts are only monomorphic *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_udecl</span> `{checker_flags} Œ£ (udecl : universes_decl)
      := <span class="kr">let</span> <span class="nv">levels</span> := levels_of_udecl udecl <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">global_levels</span> := global_levels Œ£ <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">all_levels</span> := LevelSet.union levels global_levels <span class="kr">in</span>
        LevelSet.For_all (<span class="kr">fun</span> <span class="nv">l</span> =&gt; ~ LevelSet.In l global_levels) levels
        /\ ConstraintSet.For_all (<span class="kr">fun</span> &#39;(l1,_,l2) =&gt; LevelSet.In l1 all_levels
                                                /\ LevelSet.In l2 all_levels)
                                (constraints_of_udecl udecl)
        /\ <span class="kr">match</span> udecl <span class="kr">with</span>
          | Monomorphic_ctx ctx =&gt;  LevelSet.for_all (negb ‚àò Level.<span class="nb">is_var</span>) ctx.<span class="mi">1</span>
          | _ =&gt; <span class="kt">True</span>
          <span class="kr">end</span>
        /\ satisfiable_udecl Œ£ udecl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">on_global_env</span> `{checker_flags} : global_env -&gt; <span class="kt">Type</span> :=
    | globenv_nil : on_global_env []
    | globenv_decl Œ£ kn d :
        on_global_env Œ£ -&gt;
        fresh_global kn Œ£ -&gt;
        <span class="kr">let</span> <span class="nv">udecl</span> := universes_decl_of_decl d <span class="kr">in</span>
        on_udecl Œ£ udecl -&gt;
        on_global_decl (Œ£, udecl) kn d -&gt;
        on_global_env (Œ£ ,, (kn, d)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> <span class="kr">for</span> on_global_env.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">on_global_env_ext</span> `{checker_flags} (Œ£ : global_env_ext) :=
      on_global_env Œ£.<span class="mi">1</span> √ó on_udecl Œ£.<span class="mi">1</span> Œ£.<span class="mi">2</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">GlobalMaps</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cstr_args_length {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cstr_eq {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_ctype {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_cargs {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_cindices {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_ctype_positive {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> on_ctype_variance {_ P Œ£ mdecl i idecl ind_indices cdecl cunivs}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ind_arity_eq {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ind_cunivs {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onArity {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onConstructors {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onProjections {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ind_sorts {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onIndices {_ P Œ£ mind mdecl i idecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onInductives {_ P Œ£ mind mdecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onParams {_ P Œ£ mind mdecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onNpars {_ P Œ£ mind mdecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> onVariance {_ P Œ£ mind mdecl}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk14"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">All_local_env_impl</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>) <span class="nv">l</span> :
    All_local_env P l -&gt;
    (<span class="kr">forall</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, P Œì t T -&gt; Q Œì t T) -&gt;
    All_local_env Q l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P l -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œì t T -&gt; Q Œì t T) -&gt; All_local_env Q l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P l -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œì t T -&gt; Q Œì t T) -&gt; All_local_env Q l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">intros</span>; <span class="nb">simpl</span>; <span class="nb">econstructor</span>; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk16"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">All_local_env_skipn</span> <span class="nv">P</span> <span class="nv">Œì</span> : All_local_env P Œì -&gt; <span class="kr">forall</span> <span class="nv">n</span>, All_local_env P (skipn n Œì).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P Œì -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat, All_local_env P (skipn n Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env P Œì -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat, All_local_env P (skipn n Œì)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">simpl</span>; <span class="nb">intros</span>; <span class="nb">destruct</span> n; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="nb">econstructor</span>; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> All_local_env_skipn : <span class="kn">wf</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk18"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Alli_impl_trans</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : nat -&gt; A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  Alli P n l -&gt; (<span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">x</span> : A), P n0 x -&gt; Q n0 x) -&gt; Alli Q n l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : nat -&gt; A -&gt; <span class="kt">Type</span>)
  (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
Alli P n l -&gt;
(<span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">x</span> : A), P n0 x -&gt; Q n0 x) -&gt;
Alli Q n l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : nat -&gt; A -&gt; <span class="kt">Type</span>)
  (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
Alli P n l -&gt;
(<span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">x</span> : A), P n0 x -&gt; Q n0 x) -&gt;
Alli Q n l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1a"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli P n l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">x</span> : A), P n0 x -&gt; Q n0 x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Alli Q n l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> X; <span class="nb">simpl</span>; <span class="nb">constructor</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">type_local_ctx_impl</span> (<span class="nv">P</span> <span class="nv">Q</span> : global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>) <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œî</span> <span class="nv">u</span> :
    type_local_ctx P Œ£ Œì Œî u -&gt;
    (<span class="kr">forall</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, P Œ£ Œì t T -&gt; Q Œ£ Œì t T) -&gt;
    type_local_ctx Q Œ£ Œì Œî u.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T) -&gt; type_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T) -&gt; type_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1d"><span class="highlight"><span class="nb">intros</span> HP HPQ.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">type_local_ctx P Œ£ Œì Œî u</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1e"><span class="highlight"><span class="nb">revert</span> HP; <span class="nb">induction</span> Œî <span class="kr">in</span> Œì, HPQ |- *; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> a <span class="kr">with</span>
| {| decl_body := Some b; decl_type := t |} =&gt;
    type_local_ctx P Œ£ Œì Œî u
    √ó P Œ£ (Œì,,, Œî) t None √ó P Œ£ (Œì,,, Œî) b (Some t)
| {| decl_body := None; decl_type := t |} =&gt;
    type_local_ctx P Œ£ Œì Œî u
    √ó P Œ£ (Œì,,, Œî) t (Some (tSort u))
<span class="kr">end</span> -&gt;
<span class="kr">match</span> a <span class="kr">with</span>
| {| decl_body := Some b; decl_type := t |} =&gt;
    type_local_ctx Q Œ£ Œì Œî u
    √ó Q Œ£ (Œì,,, Œî) t None √ó Q Œ£ (Œì,,, Œî) b (Some t)
| {| decl_body := None; decl_type := t |} =&gt;
    type_local_ctx Q Œ£ Œì Œî u
    √ó Q Œ£ (Œì,,, Œî) t (Some (tSort u))
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk1f"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [na [b|] ty]; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u
√ó P Œ£ (Œì,,, Œî) ty None √ó P Œ£ (Œì,,, Œî) b (Some ty) -&gt;
type_local_ctx Q Œ£ Œì Œî u
√ó Q Œ£ (Œì,,, Œî) ty None √ó Q Œ£ (Œì,,, Œî) b (Some ty)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk20"><hr></label><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u
√ó P Œ£ (Œì,,, Œî) ty (Some (tSort u)) -&gt;
type_local_ctx Q Œ£ Œì Œî u
√ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk21"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">type_local_ctx P Œ£ Œì Œî u *
(P Œ£ (Œì,,, Œî) ty None √ó P Œ£ (Œì,,, Œî) b (Some ty))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx Q Œ£ Œì Œî u *
(Q Œ£ (Œì,,, Œî) ty None √ó Q Œ£ (Œì,,, Œî) b (Some ty))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk22"><hr></label><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u
√ó P Œ£ (Œì,,, Œî) ty (Some (tSort u)) -&gt;
type_local_ctx Q Œ£ Œì Œî u
√ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk23"><span class="highlight"><span class="nb">intuition</span> <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">Œì0</span> : <span class="kp">context</span>,
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
type_local_ctx P Œ£ Œì0 Œî u -&gt; type_local_ctx Q Œ£ Œì0 Œî u</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx P Œ£ Œì Œî u
√ó P Œ£ (Œì,,, Œî) ty (Some (tSort u)) -&gt;
type_local_ctx Q Œ£ Œì Œî u
√ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intuition</span> <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk24"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">sorts_local_ctx_impl</span> (<span class="nv">P</span> <span class="nv">Q</span> : global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span>) <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œî</span> <span class="nv">u</span> :
    sorts_local_ctx P Œ£ Œì Œî u -&gt;
    (<span class="kr">forall</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, P Œ£ Œì t T -&gt; Q Œ£ Œì t T) -&gt;
    sorts_local_ctx Q Œ£ Œì Œî u.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T) -&gt;
sorts_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk25"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u -&gt;
(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T) -&gt;
sorts_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk26"><span class="highlight"><span class="nb">intros</span> HP HPQ.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q Œ£ Œì Œî u</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk27"><span class="highlight"><span class="nb">revert</span> HP; <span class="nb">induction</span> Œî <span class="kr">in</span> Œì, HPQ, u |- *; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> a <span class="kr">with</span>
| {| decl_body := Some b; decl_type := t |} =&gt;
    sorts_local_ctx P Œ£ Œì Œî u
    √ó P Œ£ (Œì,,, Œî) t None √ó P Œ£ (Œì,,, Œî) b (Some t)
| {| decl_body := None; decl_type := t |} =&gt;
    <span class="kr">match</span> u <span class="kr">with</span>
    | [] =&gt; <span class="kt">False</span>
    | u0 :: us =&gt;
        sorts_local_ctx P Œ£ Œì Œî us
        √ó P Œ£ (Œì,,, Œî) t (Some (tSort u0))
    <span class="kr">end</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> a <span class="kr">with</span>
| {| decl_body := Some b; decl_type := t |} =&gt;
    sorts_local_ctx Q Œ£ Œì Œî u
    √ó Q Œ£ (Œì,,, Œî) t None √ó Q Œ£ (Œì,,, Œî) b (Some t)
| {| decl_body := None; decl_type := t |} =&gt;
    <span class="kr">match</span> u <span class="kr">with</span>
    | [] =&gt; <span class="kt">False</span>
    | u0 :: us =&gt;
        sorts_local_ctx Q Œ£ Œì Œî us
        √ó Q Œ£ (Œì,,, Œî) t (Some (tSort u0))
    <span class="kr">end</span>
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk28"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [na [b|] ty]; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u
√ó P Œ£ (Œì,,, Œî) ty None √ó P Œ£ (Œì,,, Œî) b (Some ty) -&gt;
sorts_local_ctx Q Œ£ Œì Œî u
√ó Q Œ£ (Œì,,, Œî) ty None √ó Q Œ£ (Œì,,, Œî) b (Some ty)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk29"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx P Œ£ Œì Œî us
    √ó P Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span> -&gt;
<span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx Q Œ£ Œì Œî us
    √ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2a"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u *
(P Œ£ (Œì,,, Œî) ty None √ó P Œ£ (Œì,,, Œî) b (Some ty))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q Œ£ Œì Œî u *
(Q Œ£ (Œì,,, Œî) ty None √ó Q Œ£ (Œì,,, Œî) b (Some ty))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx P Œ£ Œì Œî us
    √ó P Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span> -&gt;
<span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx Q Œ£ Œì Œî us
    √ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2c"><span class="highlight"><span class="nb">intuition</span> <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx P Œ£ Œì Œî us
    √ó P Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span> -&gt;
<span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx Q Œ£ Œì Œî us
    √ó Q Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2d"><span class="highlight"><span class="nb">intuition</span> <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì0 t T -&gt; Q Œ£ Œì0 t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term), P Œ£ Œì1 t T -&gt; Q Œ£ Œì1 t T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx P Œ£ Œì Œî us *
    P Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> u <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| u0 :: us =&gt;
    sorts_local_ctx Q Œ£ Œì Œî us *
    Q Œ£ (Œì,,, Œî) ty (Some (tSort u0))
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2e"><span class="highlight"><span class="nb">destruct</span> u; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ty</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list context_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> : term) (<span class="nv">T</span> : option term),
P Œ£ Œì0 t0 T -&gt; Q Œ£ Œì0 t0 T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">u0</span> : list Universe.t),
(<span class="kr">forall</span> (<span class="nv">Œì1</span> : <span class="kp">context</span>) (<span class="nv">t0</span> : term) (<span class="nv">T</span> : option term),
P Œ£ Œì1 t0 T -&gt; Q Œ£ Œì1 t0 T) -&gt;
sorts_local_ctx P Œ£ Œì0 Œî u0 -&gt; sorts_local_ctx Q Œ£ Œì0 Œî u0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P Œ£ Œì Œî u *
P Œ£ (Œì,,, Œî) ty (Some (tSort t))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q Œ£ Œì Œî u *
Q Œ£ (Œì,,, Œî) ty (Some (tSort t))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intuition</span> <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
This predicate enforces that there exists typing derivations for every typable term in env. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Forall_decls_typing</span> `{checker_flags}
            (P : global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span>)
    := on_global_env (lift_typing P).</span></span></span></pre><div class="doc">
<a name="lab5"></a><h3 class="section">Typing of local environments</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">type_local_decl</span> `{checker_flags} Œ£ Œì d :=
    <span class="kr">match</span> d.(decl_body) <span class="kr">with</span>
    | None =&gt; isType Œ£ Œì d.(decl_type)
    | Some body =&gt; Œ£ ;;; Œì |- body : d.(decl_type)
    <span class="kr">end</span>.</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Induction principle for typing up-to a global environment</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">refine_type</span> `{checker_flags} Œ£ Œì t T U : Œ£ ;;; Œì |- t : T -&gt; T = U -&gt; Œ£ ;;; Œì |- t : U.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, T, U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Œ£;;; Œì |- t : T -&gt; T = U -&gt; Œ£;;; Œì |- t : U</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, T, U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Œ£;;; Œì |- t : T -&gt; T = U -&gt; Œ£;;; Œì |- t : U</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">intros</span> Ht -&gt;.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">wf_local</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{checker_flags}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">wf_local_rel</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œì&#39;</span>
      := (All_local_env (lift_typing (<span class="kr">fun</span> <span class="nv">Œ£0</span> <span class="nv">Œì0</span> <span class="nv">t</span> <span class="nv">T</span> =&gt; Œ£0 ;;; Œì ,,, Œì0 |- t : T) Œ£) Œì&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">wf_local_rel_nil</span> {<span class="nv">Œ£</span> <span class="nv">Œì</span>} : wf_local_rel Œ£ Œì []
      := localenv_nil.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">wf_local_rel_abs</span> {<span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œì&#39;</span> <span class="nv">A</span> <span class="nv">na</span>} :
      wf_local_rel Œ£ Œì Œì&#39; -&gt; {u &amp; Œ£ ;;; Œì ,,, Œì&#39; |- A : tSort u }
      -&gt; wf_local_rel Œ£ Œì (Œì&#39;,, vass na A)
      := localenv_cons_abs.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">wf_local_rel_def</span> {<span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">Œì&#39;</span> <span class="nv">t</span> <span class="nv">A</span> <span class="nv">na</span>} :
      wf_local_rel Œ£ Œì Œì&#39; -&gt;
      isType Œ£ (Œì ,,, Œì&#39;) A -&gt;
      Œ£ ;;; Œì ,,, Œì&#39; |- t : A -&gt;
      wf_local_rel Œ£ Œì (Œì&#39;,, vdef na t A)
      := localenv_cons_def.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk31"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">wf_local_rel_local</span> :
      <span class="kr">forall</span> <span class="nv">Œ£</span> <span class="nv">Œì</span>,
        wf_local Œ£ Œì -&gt;
        wf_local_rel Œ£ [] Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>),
wf_local Œ£ Œì -&gt; wf_local_rel Œ£ [] Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>),
wf_local Œ£ Œì -&gt; wf_local_rel Œ£ [] Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk33"><span class="highlight"><span class="nb">intros</span> Œ£ Œì h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">wf_local_rel Œ£ [] Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk34"><span class="highlight"><span class="nb">eapply</span> All_local_env_impl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env <span class="nl">?P</span> Œì</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk35"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
<span class="nl">?P</span> Œì0 t T -&gt;
lift_typing
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì1</span> : <span class="kp">context</span>)
     (<span class="nv">t0</span> <span class="nv">T0</span> : term) =&gt; Œ£0;;; [],,, Œì1 |- t0 : T0) Œ£ Œì0
  t T</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk36"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env <span class="nl">?P</span> Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> h.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk37"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
lift_typing typing Œ£ Œì0 t T -&gt;
lift_typing
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì1</span> : <span class="kp">context</span>)
     (<span class="nv">t0</span> <span class="nv">T0</span> : term) =&gt; Œ£0;;; [],,, Œì1 |- t0 : T0) Œ£ Œì0
  t T</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk38"><span class="highlight"><span class="nb">intros</span> Œî t [] h&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t (Some t0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">lift_typing
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì0</span> : <span class="kp">context</span>)
     (<span class="nv">t1</span> <span class="nv">T</span> : term) =&gt; Œ£0;;; [],,, Œì0 |- t1 : T) Œ£ Œî t
  (Some t0)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t None</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk39"><hr></label><div class="goal-conclusion"><span class="highlight">lift_typing
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì0</span> : <span class="kp">context</span>)
     (<span class="nv">t0</span> <span class="nv">T</span> : term) =&gt; Œ£0;;; [],,, Œì0 |- t0 : T) Œ£ Œî t
  None</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk3a"><span class="highlight"><span class="kp">all</span>: <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t (Some t0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Œ£;;; [],,, Œî |- t : t0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t None</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight">‚àë s : <span class="kn">Universe</span>.t, Œ£;;; [],,, Œî |- t : tSort s</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk3c"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t (Some t0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Œ£;;; [],,, Œî |- t : t0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk3d"><span class="highlight"><span class="nb">rewrite</span> app_context_nil_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t (Some t0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Œ£;;; Œî |- t : t0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk3e"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t None</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">‚àë s : <span class="kn">Universe</span>.t, Œ£;;; [],,, Œî |- t : tSort s</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk3f"><span class="highlight"><span class="nb">rewrite</span> app_context_nil_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local Œ£ Œì</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lift_typing typing Œ£ Œî t None</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">‚àë s : <span class="kn">Universe</span>.t, Œ£;;; Œî |- t : tSort s</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk40"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">wf_local_local_rel</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> :
      wf_local_rel Œ£ [] Œì -&gt; wf_local Œ£ Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">wf_local_rel Œ£ [] Œì -&gt; wf_local Œ£ Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk41"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">wf_local_rel Œ£ [] Œì -&gt; wf_local Œ£ Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk42"><span class="highlight"><span class="nb">intro</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local_rel Œ£ [] Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">wf_local Œ£ Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk43"><span class="highlight"><span class="nb">eapply</span> All_local_env_impl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local_rel Œ£ [] Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env <span class="nl">?P</span> Œì</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local_rel Œ£ [] Œì</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk44"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
<span class="nl">?P</span> Œì0 t T -&gt; lift_typing typing Œ£ Œì0 t T</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk45"><span class="highlight"><span class="bp">exact</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">wf_local_rel Œ£ [] Œì</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
lift_typing
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì1</span> : <span class="kp">context</span>)
     (<span class="nv">t0</span> <span class="nv">T0</span> : term) =&gt; Œ£0;;; [],,, Œì1 |- t0 : T0) Œ£ Œì0
  t T -&gt; lift_typing typing Œ£ Œì0 t T</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> Œì0 t [] XX; <span class="nb">cbn</span> <span class="kr">in</span> XX; <span class="nb">rewrite</span> app_context_nil_l <span class="kr">in</span> XX; <span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">wf_local</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">wf_local_size</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{checker_flags} (Œ£ : global_env_ext).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">fn</span> : <span class="kr">forall</span> (<span class="nv">Œ£</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term), typing Œ£ Œì t T -&gt; size).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">wf_local_size</span> <span class="nv">Œì</span> (<span class="nv">w</span> : wf_local Œ£ Œì) : size :=
      <span class="kr">match</span> w <span class="kr">with</span>
      | localenv_nil =&gt; <span class="mi">0</span>

      | localenv_cons_abs Œì na t wfŒì tty =&gt;
        (fn _ _ t _ (projT2 tty) + wf_local_size _ wfŒì)%nat

      | localenv_cons_def Œì na b t wfŒì tty tty&#39; =&gt;
        (fn _ _ t _ (projT2 tty) + fn _ _ b t tty&#39; + wf_local_size _ wfŒì)%nat
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">wf_local_size</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk46"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">lift_typing_impl</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span> :
    (<span class="kr">forall</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, P Œ£ Œì t T -&gt; Q Œ£ Œì t T) -&gt;
    lift_typing P Œ£ Œì t T -&gt; lift_typing Q Œ£ Œì t T.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T0</span> : term),
 P Œ£ Œì0 t0 T0 -&gt; Q Œ£ Œì0 t0 T0) -&gt;
lift_typing P Œ£ Œì t T -&gt; lift_typing Q Œ£ Œì t T</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T0</span> : term),
 P Œ£ Œì0 t0 T0 -&gt; Q Œ£ Œì0 t0 T0) -&gt;
lift_typing P Œ£ Œì t T -&gt; lift_typing Q Œ£ Œì t T</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk48"><span class="highlight"><span class="nb">intros</span> HPQ.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T0</span> : term), P Œ£ Œì0 t0 T0 -&gt; Q Œ£ Œì0 t0 T0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">lift_typing P Œ£ Œì t T -&gt; lift_typing Q Œ£ Œì t T</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk49"><span class="highlight"><span class="nb">destruct</span> T; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t1</span> <span class="nv">T</span> : term), P Œ£ Œì0 t1 T -&gt; Q Œ£ Œì0 t1 T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P Œ£ Œì t t0 -&gt; Q Œ£ Œì t t0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T</span> : term), P Œ£ Œì0 t0 T -&gt; Q Œ£ Œì0 t0 T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk4a"><hr></label><div class="goal-conclusion"><span class="highlight">(‚àë s : <span class="kn">Universe</span>.t, P Œ£ Œì t (tSort s)) -&gt;
‚àë s : <span class="kn">Universe</span>.t, Q Œ£ Œì t (tSort s)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4b"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, t0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t1</span> <span class="nv">T</span> : term), P Œ£ Œì0 t1 T -&gt; Q Œ£ Œì0 t1 T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P Œ£ Œì t t0 -&gt; Q Œ£ Œì t t0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> HPQ.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4c"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T</span> : term), P Œ£ Œì0 t0 T -&gt; Q Œ£ Œì0 t0 T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(‚àë s : <span class="kn">Universe</span>.t, P Œ£ Œì t (tSort s)) -&gt;
‚àë s : <span class="kn">Universe</span>.t, Q Œ£ Œì t (tSort s)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4d"><span class="highlight"><span class="nb">intros</span> [s Hs]; <span class="kr">exists</span> <span class="nv">s</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt; <span class="kp">context</span> -&gt; term -&gt; term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">HPQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì0</span> : <span class="kp">context</span>) (<span class="nv">t0</span> <span class="nv">T</span> : term), P Œ£ Œì0 t0 T -&gt; Q Œ£ Œì0 t0 T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P Œ£ Œì t (tSort s)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q Œ£ Œì t (tSort s)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> HPQ.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Functoriality of global environment typing derivations + folding of the well-formed 
    environment assumption. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">on_wf_global_env_impl</span> `{checker_flags} {Œ£ : global_env} {wfŒ£ : on_global_env (lift_typing typing) Œ£} P Q :
    (<span class="kr">forall</span> <span class="nv">Œ£</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span>, on_global_env (lift_typing typing) Œ£.<span class="mi">1</span> -&gt; 
        on_global_env P Œ£.<span class="mi">1</span> -&gt; 
        on_global_env Q Œ£.<span class="mi">1</span> -&gt;
        P Œ£ Œì t T -&gt; Q Œ£ Œì t T) -&gt;
    on_global_env P Œ£ -&gt; on_global_env Q Œ£.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
   (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
 on_global_env P Œ£0.<span class="mi">1</span> -&gt;
 on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T) -&gt;
on_global_env P Œ£ -&gt; on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
   (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
 on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
 on_global_env P Œ£0.<span class="mi">1</span> -&gt;
 on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T) -&gt;
on_global_env P Œ£ -&gt; on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk50"><span class="highlight"><span class="nb">intros</span> X X0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk51"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk52"><span class="highlight"><span class="nb">revert</span> wfŒ£.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk53"><span class="highlight"><span class="nb">induction</span> X0; <span class="nb">constructor</span>; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) (Œ£,, (kn, d))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env Q Œ£</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) 
  (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) (Œ£,, (kn, d))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk54"><hr></label><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk55"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) (Œ£,, (kn, d))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk56"><span class="highlight">depelim wfŒ£.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_env Q Œ£</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">eauto</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk57"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) (Œ£,, (kn, d))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk58"><span class="highlight">depelim wfŒ£.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£ -&gt;
on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk59"><span class="highlight"><span class="nb">specialize</span> (IHX0 wfŒ£).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œ£0</span> : global_env √ó universes_decl)
  (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
on_global_env (lift_typing typing) Œ£0.<span class="mi">1</span> -&gt;
on_global_env P Œ£0.<span class="mi">1</span> -&gt;
on_global_env Q Œ£0.<span class="mi">1</span> -&gt; P Œ£0 Œì t T -&gt; Q Œ£0 Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5a"><span class="highlight"><span class="nb">assert</span> (X&#39; := <span class="kr">fun</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">T</span> =&gt; X (Œ£, udecl0) Œì t T wfŒ£ X0 IHX0); <span class="nb">clear</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5b"><span class="highlight"><span class="nb">rename</span> X&#39; <span class="nb">into</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHX0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env Q Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5c"><span class="highlight"><span class="nb">clear</span> IHX0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl d</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn d</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_global_decl Q (Œ£, universes_decl_of_decl d) kn d</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5d"><span class="highlight"><span class="nb">destruct</span> d; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constant_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (ConstantDecl c)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn (ConstantDecl c)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (ConstantDecl c)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn (ConstantDecl c)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constant_decl Q (Œ£, cst_universes c) c</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk5e"><hr></label><div class="goal-conclusion"><span class="highlight">on_inductive Q (Œ£, ind_universes m) kn m</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk5f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constant_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (ConstantDecl c)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn (ConstantDecl c)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (ConstantDecl c)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn (ConstantDecl c)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constant_decl Q (Œ£, cst_universes c) c</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk60"><span class="highlight"><span class="nb">destruct</span> c; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cst_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cst_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cst_universes0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl
  (ConstantDecl
     {|
     cst_type := cst_type0;
     cst_body := cst_body0;
     cst_universes := cst_universes0 |})</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn
  (ConstantDecl
     {|
     cst_type := cst_type0;
     cst_body := cst_body0;
     cst_universes := cst_universes0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl
  (ConstantDecl
     {|
     cst_type := cst_type0;
     cst_body := cst_body0;
     cst_universes := cst_universes0 |})</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn
  (ConstantDecl
     {|
     cst_type := cst_type0;
     cst_body := cst_body0;
     cst_universes := cst_universes0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constant_decl Q (Œ£, cst_universes0)
  {|
  cst_type := cst_type0;
  cst_body := cst_body0;
  cst_universes := cst_universes0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> cst_body0; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">now</span> <span class="nb">eapply</span> X.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk61"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_inductive Q (Œ£, ind_universes m) kn m</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk62"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> o.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl P (Œ£, udecl) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">universes_decl_of_decl (InductiveDecl m)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_decl (lift_typing typing) 
  (Œ£, udecl0) kn (InductiveDecl m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_inductive Q (Œ£, ind_universes m) kn m</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk63"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive P (Œ£, udecl) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_inductive Q (Œ£, ind_universes m) kn m</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk64"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">as</span> [onI onP onNP].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_inductive Q (Œ£, ind_universes m) kn m</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk65"><span class="highlight"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Alli (on_ind_body Q (Œ£, ind_universes m) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk66"><hr></label><div class="goal-conclusion"><span class="highlight">on_context Q (Œ£, ind_universes m) (ind_params m)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk67"><span class="highlight">--</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Alli (on_ind_body Q (Œ£, ind_universes m) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk68"><span class="highlight"><span class="nb">eapply</span> Alli_impl; tea.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : one_inductive_body),
on_ind_body P (Œ£, udecl) kn m n x -&gt;
on_ind_body Q (Œ£, ind_universes m) kn m n x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk69"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_ind_body Q (Œ£, ind_universes m) kn m n x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk6a"><span class="highlight"><span class="nb">refine</span> {| ind_arity_eq := X1.(ind_arity_eq);
                  ind_cunivs := X1.(ind_cunivs) |}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_type Q (Œ£, ind_universes m) [] (ind_type x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk6b"><hr></label><div class="goal-conclusion"><span class="highlight">on_constructors Q (Œ£, ind_universes m) m n x
  (ind_indices x) (ind_ctors x) 
  (ind_cunivs X1)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk6c"><hr></label><div class="goal-conclusion"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt; on_projections m kn n x (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk6d"><hr></label><div class="goal-conclusion"><span class="highlight">check_ind_sorts Q (Œ£, ind_universes m) 
  (ind_params m) (ind_kelim x) 
  (ind_indices x) (ind_cunivs X1) 
  (ind_sort x)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk6e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, ind_universes m) m v
  (ind_indices x)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk6f"><span class="highlight">---</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_type Q (Œ£, ind_universes m) [] (ind_type x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk70"><span class="highlight"><span class="nb">apply</span> onArity <span class="kr">in</span> X1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_type Q (Œ£, ind_universes m) [] (ind_type x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk71"><span class="highlight"><span class="nb">unfold</span> on_type <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P (Œ£, udecl) [] (ind_type x) None</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q (Œ£, ind_universes m) [] (ind_type x) None</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">eapply</span> X.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk72"><span class="highlight">---</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constructors Q (Œ£, ind_universes m) m n x
  (ind_indices x) (ind_ctors x) (ind_cunivs X1)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk73"><span class="highlight"><span class="nb">pose proof</span> X1.(onConstructors) <span class="kr">as</span> X11.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x) 
  (ind_cunivs X1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constructors Q (Œ£, ind_universes m) m n x
  (ind_indices x) (ind_ctors x) (ind_cunivs X1)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk74"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> X11.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constructors Q (Œ£, ind_universes m) m n x
  (ind_indices x) (ind_ctors x) (ind_cunivs X1)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk75"><span class="highlight"><span class="nb">eapply</span> All2_impl; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x0</span> : constructor_body) (<span class="nv">y</span> : list Universe.t),
on_constructor P (Œ£, udecl) m n x (ind_indices x) x0 y -&gt;
on_constructor Q (Œ£, ind_universes m) m n x
  (ind_indices x) x0 y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk76"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x0</span> : constructor_body) (<span class="nv">y</span> : list Universe.t),
on_constructor P (Œ£, udecl) m n x (ind_indices x) x0 y -&gt;
on_constructor Q (Œ£, ind_universes m) m n x
  (ind_indices x) x0 y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk77"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructor P (Œ£, udecl) m n x 
  (ind_indices x) x0 y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_constructor Q (Œ£, ind_universes m) m n x
  (ind_indices x) x0 y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk78"><span class="highlight"><span class="nb">destruct</span> X2 <span class="kr">as</span> [? ? ? ?]; <span class="nb">unshelve</span> <span class="nb">econstructor</span>; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_type Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m)) (cstr_type x0)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk79"><hr></label><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m)
  (cstr_args x0) y</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) 
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; 
   Q Œ£0 Œì t (Some T)) (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x)))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7b"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_type Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m)) (cstr_type x0)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> X; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7c"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m)
  (cstr_args x0) y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7d"><span class="highlight"><span class="nb">clear</span> -X0 X on_cargs0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m)
  (cstr_args x0) y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7e"><span class="highlight"><span class="nb">revert</span> on_cargs0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,, ind_params m)
  (cstr_args x0) y -&gt;
sorts_local_ctx Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m)
  (cstr_args x0) y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk7f"><span class="highlight"><span class="nb">generalize</span> (cstr_args x0).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">c</span> : <span class="kp">context</span>,
sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,, ind_params m) c y -&gt;
sorts_local_ctx Q (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m) c y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> c <span class="kr">in</span> y |- *; <span class="nb">destruct</span> y; <span class="nb">simpl</span>; <span class="nb">auto</span>;
                <span class="nb">destruct</span> a <span class="kr">as</span> [na [b|] ty]; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>;
            <span class="nb">split</span>; <span class="nb">intuition</span> <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk80"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x1</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x1))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All2
  (on_constructor P (Œ£, udecl) m n x
     (ind_indices x)) (ind_ctors x)
  (ind_cunivs X1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list <span class="kn">Universe</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_args_length0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (cstr_args x0) =
cstr_arity x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cstr_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">cstr_type x0 =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (cstr_args x0)
     (cstr_concl m n x x0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl)
  (arities_context (ind_bodies m))
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cargs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sorts_local_ctx P (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m) (cstr_args x0) y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_positive0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive_cstr m n []
  (cstr_type x0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_ctype_variance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
cstr_respects_variance (Œ£, udecl)
  m v x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; Q Œ£0 Œì t (Some T))
  (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk81"><span class="highlight"><span class="nb">clear</span> -X0 X on_cindices0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">on_cindices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext)
     (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt;
   P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,,
   ind_params m,,, cstr_args x0)
  (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span>
        (ind_indices x)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; Q Œ£0 Œì t (Some T))
  (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk82"><span class="highlight"><span class="nb">revert</span> on_cindices0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x))) -&gt;
ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; Q Œ£0 Œì t (Some T))
  (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0)
  (List.rev
     (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk83"><span class="highlight"><span class="nb">generalize</span> (List.rev (lift_context #|cstr_args x0| <span class="mi">0</span> (ind_indices x))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">l</span> : list context_decl,
ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0) l -&gt;
ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; Q Œ£0 Œì t (Some T))
  (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) (cstr_indices x0) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk84"><span class="highlight"><span class="nb">generalize</span> (cstr_indices x0).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl, udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">constructor_body</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : list term) (<span class="nv">l0</span> : list context_decl),
ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; P Œ£0 Œì t (Some T)) (Œ£, udecl)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) l l0 -&gt;
ctx_inst
  (<span class="kr">fun</span> (<span class="nv">Œ£0</span> : global_env_ext) (<span class="nv">Œì</span> : <span class="kp">context</span>)
     (<span class="nv">t</span> <span class="nv">T</span> : term) =&gt; Q Œ£0 Œì t (Some T))
  (Œ£, ind_universes m)
  (arities_context (ind_bodies m),,, ind_params m,,,
   cstr_args x0) l l0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">simpl</span>; <span class="nb">constructor</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk85"><span class="highlight">---</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt; on_projections m kn n x (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk86"><span class="highlight"><span class="nb">simpl</span>; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; []</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt; on_projections m kn n x (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk87"><span class="highlight"><span class="nb">pose</span> (onProjections X1 H0).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; []</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">onProjections X1 H0</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt; on_projections m kn n x (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk88"><span class="highlight">---</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_ind_sorts Q (Œ£, ind_universes m) (ind_params m)
  (ind_kelim x) (ind_indices x) (ind_cunivs X1)
  (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk89"><span class="highlight"><span class="nb">destruct</span> X1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_ind_sorts P (Œ£, udecl)
  (ind_params m) (ind_kelim x)
  (ind_indices x) ind_cunivs0
  (ind_sort x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_ind_sorts Q (Œ£, ind_universes m) (ind_params m)
  (ind_kelim x) (ind_indices x)
  (ind_cunivs
     {|
     ind_arity_eq := ind_arity_eq0;
     onArity := onArity0;
     ind_cunivs := ind_cunivs0;
     onConstructors := onConstructors0;
     onProjections := onProjections0;
     ind_sorts := ind_sorts0;
     onIndices := onIndices0 |}) (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8a"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_ind_sorts P (Œ£, udecl)
  (ind_params m) (ind_kelim x)
  (ind_indices x) ind_cunivs0
  (ind_sort x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_ind_sorts Q (Œ£, ind_universes m) (ind_params m)
  (ind_kelim x) (ind_indices x) ind_cunivs0
  (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8b"><span class="highlight"><span class="nb">unfold</span> check_ind_sorts <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">if</span> <span class="kn">Universe</span>.is_prop (ind_sort x)
<span class="kr">then</span>
 is_true
   (allowed_eliminations_subset
      (ind_kelim x)
      (elim_sort_prop_ind ind_cunivs0))
<span class="kr">else</span>
 <span class="kr">if</span> <span class="kn">Universe</span>.is_sprop (ind_sort x)
 <span class="kr">then</span>
  is_true
    (allowed_eliminations_subset
       (ind_kelim x)
       (elim_sort_sprop_ind ind_cunivs0))
 <span class="kr">else</span>
  check_constructors_smaller 
    (Œ£, udecl) ind_cunivs0 
    (ind_sort x) *
  (<span class="kr">if</span> indices_matter
   <span class="kr">then</span>
    type_local_ctx P (Œ£, udecl)
      (ind_params m) (ind_indices x)
      (ind_sort x)
   <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> <span class="kn">Universe</span>.is_prop (ind_sort x)
<span class="kr">then</span>
 is_true
   (allowed_eliminations_subset (ind_kelim x)
      (elim_sort_prop_ind ind_cunivs0))
<span class="kr">else</span>
 <span class="kr">if</span> <span class="kn">Universe</span>.is_sprop (ind_sort x)
 <span class="kr">then</span>
  is_true
    (allowed_eliminations_subset (ind_kelim x)
       (elim_sort_sprop_ind ind_cunivs0))
 <span class="kr">else</span>
  check_constructors_smaller (Œ£, ind_universes m)
    ind_cunivs0 (ind_sort x) *
  (<span class="kr">if</span> indices_matter
   <span class="kr">then</span>
    type_local_ctx Q (Œ£, ind_universes m)
      (ind_params m) (ind_indices x) (ind_sort x)
   <span class="kr">else</span> <span class="kt">True</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8c"><span class="highlight"><span class="nb">destruct</span> <span class="kn">Universe</span>.is_prop; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">if</span> <span class="kn">Universe</span>.is_sprop (ind_sort x)
<span class="kr">then</span>
 is_true
   (allowed_eliminations_subset
      (ind_kelim x)
      (elim_sort_sprop_ind ind_cunivs0))
<span class="kr">else</span>
 check_constructors_smaller 
   (Œ£, udecl) ind_cunivs0 
   (ind_sort x) *
 (<span class="kr">if</span> indices_matter
  <span class="kr">then</span>
   type_local_ctx P (Œ£, udecl)
     (ind_params m) (ind_indices x)
     (ind_sort x)
  <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> <span class="kn">Universe</span>.is_sprop (ind_sort x)
<span class="kr">then</span>
 is_true
   (allowed_eliminations_subset (ind_kelim x)
      (elim_sort_sprop_ind ind_cunivs0))
<span class="kr">else</span>
 check_constructors_smaller (Œ£, ind_universes m)
   ind_cunivs0 (ind_sort x) *
 (<span class="kr">if</span> indices_matter
  <span class="kr">then</span>
   type_local_ctx Q (Œ£, ind_universes m)
     (ind_params m) (ind_indices x) (ind_sort x)
  <span class="kr">else</span> <span class="kt">True</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8d"><span class="highlight"><span class="nb">destruct</span> <span class="kn">Universe</span>.is_sprop; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx P (Œ£, udecl)
    (ind_params m) (ind_indices x)
    (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_constructors_smaller (Œ£, ind_universes m)
  ind_cunivs0 (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx Q (Œ£, ind_universes m) (ind_params m)
    (ind_indices x) (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk8e"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx P (Œ£, udecl)
    (ind_params m) (ind_indices x)
    (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_constructors_smaller (Œ£, ind_universes m)
  ind_cunivs0 (ind_sort x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="EnvironmentTyping-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx P (Œ£, udecl)
    (ind_params m) (ind_indices x)
    (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="EnvironmentTyping-v-chk8f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> indices_matter
<span class="kr">then</span>
 type_local_ctx Q (Œ£, ind_universes m) 
   (ind_params m) (ind_indices x) 
   (ind_sort x)
<span class="kr">else</span> <span class="kt">True</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk90"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx P (Œ£, udecl)
    (ind_params m) (ind_indices x)
    (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">check_constructors_smaller (Œ£, ind_universes m)
  ind_cunivs0 (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ind_sorts0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk91"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
(<span class="kr">if</span> indices_matter
 <span class="kr">then</span>
  type_local_ctx P (Œ£, udecl)
    (ind_params m) (ind_indices x)
    (ind_sort x)
 <span class="kr">else</span> <span class="kt">True</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">if</span> indices_matter
<span class="kr">then</span>
 type_local_ctx Q (Œ£, ind_universes m) (ind_params m)
   (ind_indices x) (ind_sort x)
<span class="kr">else</span> <span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk92"><span class="highlight"><span class="nb">destruct</span> indices_matter; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
type_local_ctx P (Œ£, udecl)
  (ind_params m) (ind_indices x)
  (ind_sort x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx Q (Œ£, ind_universes m) (ind_params m)
  (ind_indices x) (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk93"><span class="highlight"><span class="nb">eapply</span> type_local_ctx_impl; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_arity_eq0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_type x =
it_mkProd_or_LetIn (ind_params m)
  (it_mkProd_or_LetIn (ind_indices x)
     (tSort (ind_sort x)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onArity0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_type P (Œ£, udecl) [] (ind_type x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_cunivs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list constructor_univs</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onConstructors0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_constructors P (Œ£, udecl) m n x
  (ind_indices x) (ind_ctors x)
  ind_cunivs0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onProjections0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ind_projs x &lt;&gt; [] -&gt;
<span class="kr">match</span> ind_ctors x <span class="kr">with</span>
| [] =&gt; <span class="kt">False</span>
| [o0] =&gt;
    on_projections m kn n x
      (ind_indices x) o0
| o0 :: _ :: _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ind_sorts0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_constructors_smaller 
  (Œ£, udecl) ind_cunivs0 
  (ind_sort x) *
type_local_ctx P (Œ£, udecl)
  (ind_params m) (ind_indices x)
  (ind_sort x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onIndices0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, udecl) m v
  (ind_indices x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">type_local_ctx P (Œ£, ind_universes m) (ind_params m)
  (ind_indices x) (ind_sort x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">eapply</span> ind_sorts0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk94"><span class="highlight">---</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x0</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x0))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">one_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_ind_body P (Œ£, udecl) kn m n x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">v</span> : list Variance.t,
ind_variance m = Some v -&gt;
ind_respects_variance (Œ£, ind_universes m) m v
  (ind_indices x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">eapply</span> X1.(onIndices).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk95"><span class="highlight">--</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_context P (Œ£, udecl) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_context Q (Œ£, ind_universes m) (ind_params m)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk96"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> onP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env (P (Œ£, udecl)) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">on_context Q (Œ£, ind_universes m) (ind_params m)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="EnvironmentTyping-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="EnvironmentTyping-v-chk97"><span class="highlight"><span class="nb">red</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">checker_flags</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env_ext -&gt;
<span class="kp">context</span> -&gt; term -&gt; option term -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">global_env</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mutual_inductive_body</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env P Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LevelSet.For_all
  (<span class="kr">fun</span> <span class="nv">l</span> : LevelSet.elt =&gt;
   ~ LevelSet.In l (global_levels Œ£))
  (levels_of_udecl udecl) /\
ConstraintSet.For_all
  (<span class="kr">fun</span> &#39;(l1, _, l2) =&gt;
   LevelSet.In l1
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)) /\
   LevelSet.In l2
     (LevelSet.union (levels_of_udecl udecl)
        (global_levels Œ£)))
  (constraints_of_udecl udecl) /\
<span class="kr">match</span> udecl <span class="kr">with</span>
| Monomorphic_ctx ctx =&gt;
    LevelSet.for_all
      (<span class="kr">fun</span> <span class="nv">x</span> : Level.t =&gt; negb (Level.<span class="nb">is_var</span> x))
      ctx.<span class="mi">1</span>
| Polymorphic_ctx _ =&gt; <span class="kt">True</span>
<span class="kr">end</span> /\ satisfiable_udecl Œ£ udecl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onI</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Alli (on_ind_body P (Œ£, udecl) kn m) <span class="mi">0</span>
  (ind_bodies m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All_local_env (P (Œ£, udecl)) (ind_params m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onNP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_assumptions (ind_params m) =
ind_npars m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">onVariance0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_variance (ind_universes m)
  (ind_variance m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wfŒ£</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_global_env (lift_typing typing) Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fresh_global kn Œ£</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">udecl0</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">ind_universes m</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">universes_decl</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_udecl Œ£ udecl0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">on_inductive (lift_typing typing) 
  (Œ£, udecl0) kn m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Œì</span> : <span class="kp">context</span>) (<span class="nv">t</span> : term) (<span class="nv">T</span> : option term),
P (Œ£, udecl0) Œì t T -&gt; Q (Œ£, udecl0) Œì t T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All_local_env (Q (Œ£, ind_universes m)) (ind_params m)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">eapply</span> All_local_env_impl; tea.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">DeclarationTyping</span>.</span></span></span></pre></article></body></html>