<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Ast.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.11.0+0.11.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Distributed under the terms of the MIT license. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Import</span> utils Environment.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Export</span> Universes.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* For primitive integers and floats  *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require</span> Int63 Floats.PrimFloat Floats.SpecFloat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Morphisms.</span></span></span></pre><div class="doc">
<a name="lab1"></a><h1 class="section">AST of Coq kernel terms and kernel data structures</h1>
<div class="paragraph"> </div>
<a name="lab2"></a><h2 class="section">Basic data-types:</h2>
<div class="paragraph"> </div>

      We reflect identifiers <span class="inlinecode"><span class="id" title="var">ident</span></span>, sort families <span class="inlinecode"><span class="id" title="var">sort_family</span></span>, names
    <span class="inlinecode"><span class="id" title="var">name</span></span>, cast kinds <span class="inlinecode"><span class="id" title="var">cast_kind</span></span>, inductives <span class="inlinecode"><span class="id" title="var">inductive</span></span> and primitive
    projections <span class="inlinecode"><span class="id" title="var">projection</span></span> and (co)-fixpoint blocks <span class="inlinecode"><span class="id" title="var">mfixpoint</span></span> and
    <span class="inlinecode"><span class="id" title="var">def</span></span>. These are defined in the <span class="inlinecode"><span class="id" title="var">BasicAst</span></span> file.

<div class="paragraph"> </div>
<a name="lab3"></a><h2 class="section">Terms:</h2>
<div class="paragraph"> </div>

      The AST is <span class="inlinecode"><span class="id" title="var">term</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
<div class="paragraph"> </div>

      Smart constructors <span class="inlinecode"><span class="id" title="var">mkApp</span></span>, <span class="inlinecode"><span class="id" title="var">mkApps</span></span> maintain the invariant
    of no nested or empty n-ary applications.
      List in fixpoints and cofixpoint should be non-empty.

<div class="paragraph"> </div>
<a name="lab4"></a><h2 class="section">Kernel interface: entries and declarations</h2>
<div class="paragraph"> </div>

      Kernel input declarations for constants <span class="inlinecode"><span class="id" title="var">constant_entry</span></span> and mutual
    inductives <span class="inlinecode"><span class="id" title="var">mutual_inductive_entry</span></span>. Kernel safe declarations for
    constants <span class="inlinecode"><span class="id" title="var">constand_decl</span></span> and inductives <span class="inlinecode"><span class="id" title="var">minductive_decl</span></span>.

<div class="paragraph"> </div>
<a name="lab5"></a><h2 class="section">Environments of declarations</h2>
<div class="paragraph"> </div>

      The global environment <span class="inlinecode"><span class="id" title="var">global_env_ext</span></span>: a list of <span class="inlinecode"><span class="id" title="var">global_decl</span></span> and
    a universe graph <span class="inlinecode"><span class="id" title="var">constraints</span></span>.  
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Export</span> BasicAst.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Defined here since BasicAst does not have access to universe instances.</span>
<span class="c">  Parameterized by term types as they are not yet defined. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">predicate</span> {<span class="nv">term</span>} := mk_predicate {
  puinst : <span class="kn">Instance</span>.t; <span class="c">(* The universe instance *)</span>
  pparams : list term; <span class="c">(* The parameters *)</span>
  pcontext : list aname; <span class="c">(* Names of binders of indices and inductive application,</span>
<span class="c">                          in same order as context (i.e. name of &quot;inductive application&quot;</span>
<span class="c">                          binder is first). Types are obtained from inductive declaration.</span>
<span class="c">                          Also used for lifting/substitution for the return type. *)</span>
  preturn : term; <span class="c">(* The return type *)</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> predicate : <span class="kn">clear implicits</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> mk_predicate {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> predicate.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk0"><span class="highlight"><span class="kn">Instance</span> <span class="nf">predicate_eq_dec</span> <span class="nv">term</span> :
  Classes.EqDec term -&gt;
  Classes.EqDec (predicate term).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec term -&gt; Classes.EqDec (predicate term)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec term -&gt; Classes.EqDec (predicate term)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">ltac</span>:(Equations.<span class="kt">Prop</span>.Tactics.eqdec_proof).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_predicate</span> {<span class="nv">term</span>} (<span class="nv">f</span> : term -&gt; string) (<span class="nv">p</span> : predicate term) :=
  <span class="s2">&quot;(&quot;</span> ^ <span class="s2">&quot;(&quot;</span> ^ String.concat <span class="s2">&quot;,&quot;</span> (map f (pparams p)) ^ <span class="s2">&quot;)&quot;</span> 
  ^ <span class="s2">&quot;,&quot;</span> ^ string_of_universe_instance (puinst p)
  ^ <span class="s2">&quot;,(&quot;</span> ^ String.concat <span class="s2">&quot;,&quot;</span> (map (string_of_name ‚àò binder_name) (pcontext p)) ^ <span class="s2">&quot;)&quot;</span>
  ^ <span class="s2">&quot;,&quot;</span> ^ f (preturn p) ^ <span class="s2">&quot;)&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">test_predicate</span> {<span class="nv">term</span>}
            (<span class="nv">instf</span> : Instance.t -&gt; bool) (<span class="nv">paramf</span> <span class="nv">preturnf</span> : term -&gt; bool) (<span class="nv">p</span> : predicate term) :=
  instf p.(puinst) &amp;&amp; forallb paramf p.(pparams) &amp;&amp; preturnf p.(preturn).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eqb_predicate</span> {<span class="nv">term</span>} (<span class="nv">eqb_univ_instance</span> : Instance.t -&gt; Instance.t -&gt; bool) (<span class="nv">eqterm</span> : term -&gt; term -&gt; bool) (<span class="nv">p</span> <span class="nv">p&#39;</span> : predicate term) :=
  forallb2 eqterm p.(pparams) p&#39;.(pparams) &amp;&amp;
  eqb_univ_instance p.(puinst) p&#39;.(puinst) &amp;&amp;
  forallb2 eqb_binder_annot p.(pcontext) p&#39;.(pcontext) &amp;&amp;
  eqterm p.(preturn) p&#39;.(preturn).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">map_predicate</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> : <span class="kt">Type</span>}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">uf</span> : Instance.t -&gt; Instance.t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">paramf</span> <span class="nv">preturnf</span> : term -&gt; term&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_predicate</span> (<span class="nv">p</span> : predicate term) :=
    {| pparams := map paramf p.(pparams);
        puinst := uf p.(puinst);
        pcontext := p.(pcontext);
        preturn := preturnf p.(preturn) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_pparams</span> (<span class="nv">p</span> : predicate term) :
    map paramf (pparams p) = pparams (map_predicate p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map paramf (pparams p) = pparams (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map paramf (pparams p) = pparams (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_preturn</span> (<span class="nv">p</span> : predicate term) :
    preturnf (preturn p) = preturn (map_predicate p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">preturnf (preturn p) = preturn (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">preturnf (preturn p) = preturn (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_puints</span> (<span class="nv">p</span> : predicate term) :
    uf (puinst p) = puinst (map_predicate p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">uf (puinst p) = puinst (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">paramf, preturnf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">uf (puinst p) = puinst (map_predicate p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">map_predicate</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_predicate_map_predicate</span>
      {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span>}
      (<span class="nv">finst</span> <span class="nv">finst&#39;</span> : Instance.t -&gt; Instance.t)
      (<span class="nv">f</span> <span class="nv">g</span> : term&#39; -&gt; term&#39;&#39;)
      (<span class="nv">f&#39;</span> <span class="nv">g&#39;</span> : term -&gt; term&#39;)
      (<span class="nv">p</span> : predicate term) :
  map_predicate finst f g (map_predicate finst&#39; f&#39; g&#39; p) =
  map_predicate (finst ‚àò finst&#39;) (f ‚àò f&#39;) (g ‚àò g&#39;) p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f', g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate finst f g (map_predicate finst&#39; f&#39; g&#39; p) =
map_predicate (finst ‚àò finst&#39;) (f ‚àò f&#39;) (g ‚àò g&#39;) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f', g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate finst f g (map_predicate finst&#39; f&#39; g&#39; p) =
map_predicate (finst ‚àò finst&#39;) (f ‚àò f&#39;) (g ‚àò g&#39;) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chka"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">cbv</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f', g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">puinst0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pparams0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">preturn0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
puinst := finst (finst&#39; puinst0);
pparams := (<span class="kr">fix</span> map (l : list term&#39;) : list term&#39;&#39; :=
              <span class="kr">match</span> l <span class="kr">with</span>
              | [] =&gt; []
              | a :: t =&gt; f a :: map t
              <span class="kr">end</span>)
             ((<span class="kr">fix</span> map (l : list term) : list term&#39; :=
                 <span class="kr">match</span> l <span class="kr">with</span>
                 | [] =&gt; []
                 | a :: t =&gt; f&#39; a :: map t
                 <span class="kr">end</span>) pparams0);
pcontext := pcontext0;
preturn := g (g&#39; preturn0) |} =
{|
puinst := finst (finst&#39; puinst0);
pparams := (<span class="kr">fix</span> map (l : list term) : list term&#39;&#39; :=
              <span class="kr">match</span> l <span class="kr">with</span>
              | [] =&gt; []
              | a :: t =&gt; f (f&#39; a) :: map t
              <span class="kr">end</span>) pparams0;
pcontext := pcontext0;
preturn := g (g&#39; preturn0) |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chkb"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f', g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">puinst0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pparams0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">preturn0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fix</span> map (l : list term&#39;) : list term&#39;&#39; :=
   <span class="kr">match</span> l <span class="kr">with</span>
   | [] =&gt; []
   | a :: t =&gt; f a :: map t
   <span class="kr">end</span>)
  ((<span class="kr">fix</span> map (l : list term) : list term&#39; :=
      <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; []
      | a :: t =&gt; f&#39; a :: map t
      <span class="kr">end</span>) pparams0) =
(<span class="kr">fix</span> map (l : list term) : list term&#39;&#39; :=
   <span class="kr">match</span> l <span class="kr">with</span>
   | [] =&gt; []
   | a :: t =&gt; f (f&#39; a) :: map t
   <span class="kr">end</span>) pparams0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chkc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_predicate_id</span> {<span class="nv">t</span>} <span class="nv">x</span> : map_predicate (@id _) (@id t) (@id t) x = id x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate id id id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chkd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate id id id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chke"><span class="highlight"><span class="nb">destruct</span> x; <span class="nb">cbv</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">puinst0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pparams0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">preturn0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
puinst := puinst0;
pparams := (<span class="kr">fix</span> map (l : list t) : list t :=
              <span class="kr">match</span> l <span class="kr">with</span>
              | [] =&gt; []
              | a :: t0 =&gt; a :: map t0
              <span class="kr">end</span>) pparams0;
pcontext := pcontext0;
preturn := preturn0 |} =
{|
puinst := puinst0;
pparams := pparams0;
pcontext := pcontext0;
preturn := preturn0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chkf"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">puinst0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pparams0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">preturn0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fix</span> map (l : list t) : list t :=
   <span class="kr">match</span> l <span class="kr">with</span>
   | [] =&gt; []
   | a :: t0 =&gt; a :: map t0
   <span class="kr">end</span>) pparams0 = pparams0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_id.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @map_predicate_id : map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tCasePredProp</span> {<span class="nv">term</span>}
            (<span class="nv">Pparams</span> <span class="nv">Preturn</span> : term -&gt; <span class="kt">Type</span>)
            (<span class="nv">p</span> : predicate term) :=
  All Pparams p.(pparams) √ó Preturn p.(preturn).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_predicate_eq_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">finst</span> <span class="nv">finst&#39;</span> : Instance.t -&gt; Instance.t) (<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B) (<span class="nv">p</span> : predicate A) :
  finst (puinst p) = finst&#39; (puinst p) -&gt;
  map f (pparams p) = map g (pparams p) -&gt;
  f&#39; (preturn p) = g&#39; (preturn p) -&gt;
  map_predicate finst f f&#39; p = map_predicate finst&#39; g g&#39; p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">finst (puinst p) = finst&#39; (puinst p) -&gt;
map f (pparams p) = map g (pparams p) -&gt;
f&#39; (preturn p) = g&#39; (preturn p) -&gt;
map_predicate finst f f&#39; p =
map_predicate finst&#39; g g&#39; p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">finst (puinst p) = finst&#39; (puinst p) -&gt;
map f (pparams p) = map g (pparams p) -&gt;
f&#39; (preturn p) = g&#39; (preturn p) -&gt;
map_predicate finst f f&#39; p =
map_predicate finst&#39; g g&#39; p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk12"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst, finst'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">finst (puinst p) = finst&#39; (puinst p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">map f (pparams p) = map g (pparams p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f&#39; (preturn p) = g&#39; (preturn p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate finst f f&#39; p =
map_predicate finst&#39; g g&#39; p</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> map_predicate; <span class="nb">f_equal</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_predicate_eq_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk13"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_predicate_id_spec</span> {<span class="nv">A</span>} <span class="nv">finst</span> (<span class="nv">f</span> <span class="nv">f&#39;</span> : A -&gt; A) (<span class="nv">p</span> : predicate A) :
  finst (puinst p) = puinst p -&gt;
  map f (pparams p) = pparams p -&gt;
  f&#39; (preturn p) = preturn p -&gt;
  map_predicate finst f f&#39; p = p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">finst (puinst p) = puinst p -&gt;
map f (pparams p) = pparams p -&gt;
f&#39; (preturn p) = preturn p -&gt;
map_predicate finst f f&#39; p = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">finst (puinst p) = puinst p -&gt;
map f (pparams p) = pparams p -&gt;
f&#39; (preturn p) = preturn p -&gt;
map_predicate finst f f&#39; p = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk15"><span class="highlight"><span class="nb">unfold</span> map_predicate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">finst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">finst (puinst p) = puinst p -&gt;
map f (pparams p) = pparams p -&gt;
f&#39; (preturn p) = preturn p -&gt;
{|
puinst := finst (puinst p);
pparams := map f (pparams p);
pcontext := pcontext p;
preturn := f&#39; (preturn p) |} = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> -&gt; -&gt; -&gt;; <span class="nb">destruct</span> p; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_predicate_id_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk16"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_predicate_proper</span> {<span class="nv">term</span>} : Proper (`=<span class="mi">1</span>` ==&gt; `=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq)%signature (@map_predicate term term id).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; (`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq)
  (map_predicate id)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; (`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq)
  (map_predicate id)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk18"><span class="highlight"><span class="nb">intros</span> eqf0 eqf1 eqf.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq)%signature
  (map_predicate id eqf0) (map_predicate id eqf1)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk19"><span class="highlight"><span class="nb">intros</span> eqf&#39;0 eqf&#39;1 eqf&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'0, eqf'1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf&#39;0 =<span class="mi">1</span> eqf&#39;1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eq ==&gt; eq)%signature (map_predicate id eqf0 eqf&#39;0)
  (map_predicate id eqf1 eqf&#39;1)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1a"><span class="highlight"><span class="nb">intros</span> x y -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'0, eqf'1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf&#39;0 =<span class="mi">1</span> eqf&#39;1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate id eqf0 eqf&#39;0 y =
map_predicate id eqf1 eqf&#39;1 y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1b"><span class="highlight"><span class="nb">apply</span> map_predicate_eq_spec; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'0, eqf'1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf&#39;0 =<span class="mi">1</span> eqf&#39;1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map eqf0 (pparams y) = map eqf1 (pparams y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> map_ext =&gt; x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1c"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_predicate_proper&#39;</span> {<span class="nv">term</span>} <span class="nv">f</span> : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@map_predicate term term id f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) (map_predicate id f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) (map_predicate id f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1e"><span class="highlight"><span class="nb">intros</span> eqf0 eqf1 eqf.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eq ==&gt; eq)%signature (map_predicate id f eqf0)
  (map_predicate id f eqf1)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk1f"><span class="highlight"><span class="nb">intros</span> x y -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_predicate id f eqf0 y = map_predicate id f eqf1 y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_predicate_eq_spec; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">shiftf</span> f k := (<span class="kr">fun</span> <span class="nv">k&#39;</span> =&gt; f (k&#39; + k)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">map_predicate_k</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> : <span class="kt">Type</span>}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">uf</span> : Instance.t -&gt; Instance.t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">f</span> : nat -&gt; term -&gt; term).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_predicate_k</span> <span class="nv">k</span> (<span class="nv">p</span> : predicate term) :=
    {| pparams := map (f k) p.(pparams);
        puinst := uf p.(puinst);
        pcontext := p.(pcontext);
        preturn := f (#|p.(pcontext)| + k) p.(preturn) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk20"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_k_pparams</span> <span class="nv">k</span> (<span class="nv">p</span> : predicate term) :
    map (f k) (pparams p) = pparams (map_predicate_k k p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (f k) (pparams p) = pparams (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk21"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (f k) (pparams p) = pparams (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk22"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_k_preturn</span> <span class="nv">k</span> (<span class="nv">p</span> : predicate term) :
    f (#|p.(pcontext)| + k) (preturn p) = preturn (map_predicate_k k p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (#|pcontext p| + k) (preturn p) =
preturn (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk23"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (#|pcontext p| + k) (preturn p) =
preturn (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk24"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_k_pcontext</span> <span class="nv">k</span> (<span class="nv">p</span> : predicate term) :
    pcontext p = pcontext (map_predicate_k k p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pcontext p = pcontext (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk25"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pcontext p = pcontext (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk26"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_k_puinst</span> <span class="nv">k</span> (<span class="nv">p</span> : predicate term) :
    uf (puinst p) = puinst (map_predicate_k k p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">uf (puinst p) = puinst (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk27"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">uf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">Instance</span>.t -&gt; <span class="kn">Instance</span>.t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">predicate term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">uf (puinst p) = puinst (map_predicate_k k p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">test_predicate_k</span> (<span class="nv">instp</span> : Instance.t -&gt; bool) 
    (<span class="nv">p</span> : nat -&gt; term -&gt; bool) <span class="nv">k</span> (<span class="nv">pred</span> : predicate term) :=
    instp pred.(puinst) &amp;&amp; forallb (p k) pred.(pparams) &amp;&amp; 
    p (#|pred.(pcontext)| + k) pred.(preturn).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">map_predicate_k</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Branch</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> : <span class="kt">Type</span>}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* Parameterized by term types as they are not yet defined. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">branch</span> := mk_branch {
    bcontext : list aname; <span class="c">(* Names of binders of the branch, in &quot;context&quot; order.</span>
<span class="c">                          Also used for lifting/substitution for the branch body. *)</span>
    bbody : term; <span class="c">(* The branch body *)</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> branch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk28"><span class="highlight"><span class="kn">Instance</span> <span class="nf">branch_eq_dec</span> :
    Classes.EqDec term -&gt;
    Classes.EqDec branch.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec term -&gt; Classes.EqDec branch</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk29"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec term -&gt; Classes.EqDec branch</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">ltac</span>:(Equations.<span class="kt">Prop</span>.Tactics.eqdec_proof).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_branch</span> (<span class="nv">f</span> : term -&gt; string) (<span class="nv">b</span> : branch) :=
  <span class="s2">&quot;([&quot;</span> ^ String.concat <span class="s2">&quot;,&quot;</span> (map (string_of_name ‚àò binder_name) (bcontext b)) ^ <span class="s2">&quot;], &quot;</span>
  ^ f (bbody b) ^ <span class="s2">&quot;)&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pretty_string_of_branch</span> (<span class="nv">f</span> : term -&gt; string) (<span class="nv">b</span> : branch) :=
    String.concat <span class="s2">&quot; &quot;</span> (map (string_of_name ‚àò binder_name) (bcontext b)) ^ <span class="s2">&quot; =&gt; &quot;</span> ^ f (bbody b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">test_branch</span> (<span class="nv">bodyf</span> : term -&gt; bool) (<span class="nv">b</span> : branch) :=
    bodyf b.(bbody).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Branch</span>.</span></span><span class="alectryon-wsp">  
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> branch : <span class="kn">clear implicits</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">map_branch</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> : <span class="kt">Type</span>}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">bbodyf</span> : term -&gt; term&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_branch</span> (<span class="nv">b</span> : branch term) :=
    {| bcontext := b.(bcontext);
      bbody := bbodyf b.(bbody) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_bbody</span> (<span class="nv">b</span> : branch term) :
      bbodyf (bbody b) = bbody (map_branch b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbodyf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bbodyf (bbody b) = bbody (map_branch b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbodyf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">bbodyf (bbody b) = bbody (map_branch b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> b; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">map_branch</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branch_map_branch</span>
      {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span>}
      (<span class="nv">f</span> : term&#39; -&gt; term&#39;&#39;)
      (<span class="nv">f&#39;</span> : term -&gt; term&#39;)
      (<span class="nv">b</span> : branch term) :
  map_branch f (map_branch f&#39; b) =
  map_branch (f ‚àò f&#39;) b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f (map_branch f&#39; b) = map_branch (f ‚àò f&#39;) b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f (map_branch f&#39; b) = map_branch (f ‚àò f&#39;) b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2e"><span class="highlight"><span class="nb">destruct</span> b; <span class="nb">cbv</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{| bcontext := bcontext0; bbody := f (f&#39; bbody0) |} =
{| bcontext := bcontext0; bbody := f (f&#39; bbody0) |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branch_id</span> {<span class="nv">t</span>} <span class="nv">x</span> : map_branch (@id t) x = id x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk31"><span class="highlight"><span class="nb">destruct</span> x; <span class="nb">cbv</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{| bcontext := bcontext0; bbody := bbody0 |} =
{| bcontext := bcontext0; bbody := bbody0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @map_branch_id : map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk32"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branch_eq_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">x</span> : branch A) :
  f (bbody x) = g (bbody x) -&gt;
  map_branch f x = map_branch g x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (bbody x) = g (bbody x) -&gt;
map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk33"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (bbody x) = g (bbody x) -&gt;
map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk34"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (bbody x) = g (bbody x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> map_branch; <span class="nb">f_equal</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_branch_eq_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk35"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_branch_proper</span> {<span class="nv">term</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@map_branch term term).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_branch</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_branch</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk37"><span class="highlight"><span class="nb">intros</span> eqf0 eqf1 eqf.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eq ==&gt; eq)%signature (map_branch eqf0)
  (map_branch eqf1)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk38"><span class="highlight"><span class="nb">intros</span> x y -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf0, eqf1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eqf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqf0 =<span class="mi">1</span> eqf1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch eqf0 y = map_branch eqf1 y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_branch_eq_spec; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk39"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branch_id_spec</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; A) (<span class="nv">x</span> : branch A) :
  f (bbody x) = (bbody x) -&gt;
  map_branch f x = x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (bbody x) = bbody x -&gt; map_branch f x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (bbody x) = bbody x -&gt; map_branch f x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3b"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (bbody x) = bbody x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3c"><span class="highlight"><span class="nb">rewrite</span> (map_branch_eq_spec _ id); <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (bbody x) = bbody x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch id x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_branch_id_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branches_map_branches</span>
      {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span>}
      (<span class="nv">f</span> : term&#39; -&gt; term&#39;&#39;)
      (<span class="nv">f&#39;</span> : term -&gt; term&#39;)
      (<span class="nv">l</span> : list (branch term)) :
  map (<span class="kr">fun</span> <span class="nv">b</span> =&gt; map_branch f (map_branch f&#39; b)) l =
  map (map_branch (f ‚àò f&#39;)) l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch f (map_branch f&#39; b)) l =
map (map_branch (f ‚àò f&#39;)) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch f (map_branch f&#39; b)) l =
map (map_branch (f ‚àò f&#39;)) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk3f"><span class="highlight"><span class="nb">eapply</span> map_ext =&gt; b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f (map_branch f&#39; b) =
map_branch (<span class="kr">fun</span> <span class="nv">x</span> : term =&gt; f (f&#39; x)) b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_branch_map_branch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_branches</span> {<span class="nv">term</span> <span class="nv">B</span>} (<span class="nv">f</span> : term -&gt; B) <span class="nv">l</span> := List.map (map_branch f) l.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tCaseBrsProp</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list (branch A)) :=
  All (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (bbody x)) l.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">map_branches_k</span> f k brs :=
  (List.map (<span class="kr">fun</span> <span class="nv">b</span> =&gt; map_branch (f (#|b.(bcontext)| + k)) b) brs).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">test_branches_k</span> test k brs :=
  (List.forallb (<span class="kr">fun</span> <span class="nv">b</span> =&gt; test_branch (test (#|b.(bcontext)| + k)) b) brs).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk40"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_branches_k_map_branches_k</span>
      {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span>}
      (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term&#39;&#39;)
      (<span class="nv">g</span> : term -&gt; term&#39;)
      (<span class="nv">f&#39;</span> : nat -&gt; term -&gt; term&#39;) <span class="nv">k</span>
      (<span class="nv">l</span> : list (branch term)) :
  map (<span class="kr">fun</span> <span class="nv">b</span> =&gt; map_branch (f #|bcontext (map_branch g b)|) (map_branch (f&#39; k) b)) l =
  map (<span class="kr">fun</span> <span class="nv">b</span> =&gt; map_branch (f #|bcontext b|) (map_branch (f&#39; k) b)) l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch (f #|bcontext (map_branch g b)|)
     (map_branch (f&#39; k) b)) l =
map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch (f #|bcontext b|) (map_branch (f&#39; k) b))
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk41"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch (f #|bcontext (map_branch g b)|)
     (map_branch (f&#39; k) b)) l =
map
  (<span class="kr">fun</span> <span class="nv">b</span> : branch term =&gt;
   map_branch (f #|bcontext b|) (map_branch (f&#39; k) b))
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk42"><span class="highlight"><span class="nb">eapply</span> map_ext =&gt; b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch (f #|bcontext (map_branch g b)|)
  (map_branch (f&#39; k) b) =
map_branch (f #|bcontext b|) (map_branch (f&#39; k) b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk43"><span class="highlight"><span class="nb">rewrite</span> map_branch_map_branch.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch
  (<span class="kr">fun</span> <span class="nv">x</span> : term =&gt;
   f #|bcontext (map_branch g b)| (f&#39; k x)) b =
map_branch (f #|bcontext b|) (map_branch (f&#39; k) b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk44"><span class="highlight"><span class="nb">rewrite</span> map_branch_map_branch.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch
  (<span class="kr">fun</span> <span class="nv">x</span> : term =&gt;
   f #|bcontext (map_branch g b)| (f&#39; k x)) b =
map_branch (<span class="kr">fun</span> <span class="nv">x</span> : term =&gt; f #|bcontext b| (f&#39; k x))
  b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> map_branch_eq_spec.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk45"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">case_brs_map_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">l</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} :
  tCaseBrsProp P l -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; f x = g x) -&gt;
  map_branches f l = map_branches g l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x) -&gt;
map_branches f l = map_branches g l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk46"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x) -&gt;
map_branches f l = map_branches g l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk47"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tCaseBrsProp P l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branches f l = map_branches g l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk48"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branches f l = map_branches g l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk49"><span class="highlight"><span class="nb">eapply</span> All_map_eq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; map_branch f x = map_branch g x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4a"><span class="highlight"><span class="nb">eapply</span> All_impl; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
(<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt; P (bbody x0)) x -&gt;
map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4b"><span class="highlight"><span class="nb">simpl</span>; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt; P (bbody x0)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A, P x0 -&gt; f x0 = g x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P (bbody x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_branch_eq_spec; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">case_brs_map_k_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">k</span> <span class="nv">l</span>} {<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; A -&gt; B} :
  tCaseBrsProp P l -&gt; (<span class="kr">forall</span> <span class="nv">k</span> <span class="nv">x</span>, P x -&gt; f k x = g k x) -&gt;
  map_branches_k f k l = map_branches_k g k l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
(<span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x) -&gt;
map_branches_k f k l = map_branches_k g k l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
(<span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x) -&gt;
map_branches_k f k l = map_branches_k g k l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4e"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tCaseBrsProp P l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branches_k f k l = map_branches_k g k l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk4f"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branches_k f k l = map_branches_k g k l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk50"><span class="highlight"><span class="nb">eapply</span> All_map_eq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt;
   map_branch (f (#|bcontext x| + k)) x =
   map_branch (g (#|bcontext x| + k)) x) l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk51"><span class="highlight"><span class="nb">eapply</span> All_impl; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x</span> : A), P x -&gt; f k0 x = g k0 x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
(<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt; P (bbody x0)) x -&gt;
map_branch (f (#|bcontext x| + k)) x =
map_branch (g (#|bcontext x| + k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk52"><span class="highlight"><span class="nb">simpl</span>; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt; P (bbody x0)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k0</span> : nat) (<span class="nv">x0</span> : A),
P x0 -&gt; f k0 x0 = g k0 x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">branch A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P (bbody x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_branch (f (#|bcontext x| + k)) x =
map_branch (g (#|bcontext x| + k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> map_branch_eq_spec; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk53"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">case_brs_forallb_map_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">p</span> : A -&gt; bool}
      {<span class="nv">l</span>} {<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B} :
  tCaseBrsProp P l -&gt;
  forallb (test_branch p) l -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; p x -&gt; f x = g x) -&gt;
  map (map_branch f) l = map (map_branch g) l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
forallb (test_branch p) l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x) -&gt;
map (map_branch f) l = map (map_branch g) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk54"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tCaseBrsProp P l -&gt;
forallb (test_branch p) l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x) -&gt;
map (map_branch f) l = map (map_branch g) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk55"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tCaseBrsProp P l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (forallb (test_branch p) l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (map_branch f) l = map (map_branch g) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk56"><span class="highlight"><span class="nb">eapply</span> All_map_eq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tCaseBrsProp P l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (forallb (test_branch p) l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; map_branch f x = map_branch g x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk57"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (forallb (test_branch p) l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; map_branch f x = map_branch g x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk58"><span class="highlight"><span class="nb">apply</span> forallb_All <span class="kr">in</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; map_branch f x = map_branch g x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk59"><span class="highlight"><span class="nb">eapply</span> All_impl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?P</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk5a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
<span class="nl">?P</span> x -&gt; map_branch f x = map_branch g x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk5b"><span class="highlight"><span class="nb">eapply</span> All_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?P</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk5c"><hr></label><div class="goal-conclusion"><span class="highlight">All <span class="nl">?Q</span> l</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Ast-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk5d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
(<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt; <span class="nl">?P</span> x0 * <span class="nl">?Q</span> x0) x -&gt;
map_branch f x = map_branch g x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk5e"><span class="highlight"><span class="bp">exact</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?Q</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk5f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
(<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : branch A =&gt; P (bbody x1)) x0 * <span class="nl">?Q</span> x0) x -&gt;
map_branch f x = map_branch g x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk60"><span class="highlight"><span class="bp">exact</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : branch A,
(<span class="kr">fun</span> <span class="nv">x0</span> : branch A =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : branch A =&gt; P (bbody x1)) x0 *
 (<span class="kr">fun</span> <span class="nv">x1</span> : branch A =&gt; is_true (test_branch p x1)) x0)
  x -&gt; map_branch f x = map_branch g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk61"><span class="highlight"><span class="nb">intros</span> [] []; <span class="nb">unfold</span> map_branch; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P
  (bbody
     {| bcontext := bcontext0; bbody := bbody0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true
  (test_branch p
     {| bcontext := bcontext0; bbody := bbody0 |})</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{| bcontext := bcontext0; bbody := f bbody0 |} =
{| bcontext := bcontext0; bbody := g bbody0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk62"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (branch A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; P (bbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : branch A =&gt; test_branch p x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bcontext0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P
  (bbody
     {| bcontext := bcontext0; bbody := bbody0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true
  (test_branch p
     {| bcontext := bcontext0; bbody := bbody0 |})</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f bbody0 = g bbody0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> H0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk63"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">tfix_forallb_map_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> <span class="nv">P&#39;</span> : A -&gt; <span class="kt">Prop</span>} {<span class="nv">p</span> <span class="nv">p&#39;</span>} {<span class="nv">l</span>} {<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B} :
  tFixProp P P&#39; l -&gt;
  forallb (test_def p p&#39;) l -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; p x -&gt; f x = g x) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
  map (map_def f f&#39;) l = map (map_def g g&#39;) l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tFixProp P P&#39; l -&gt;
forallb (test_def p p&#39;) l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk64"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tFixProp P P&#39; l -&gt;
forallb (test_def p p&#39;) l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk65"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tFixProp P P&#39; l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (forallb (test_def p p&#39;) l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk66"><span class="highlight"><span class="nb">eapply</span> All_map_eq; <span class="nb">red</span> <span class="kr">in</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (forallb (test_def p p&#39;) l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; map_def f f&#39; x = map_def g g&#39; x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk67"><span class="highlight"><span class="nb">apply</span> forallb_All <span class="kr">in</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; map_def f f&#39; x = map_def g g&#39; x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk68"><span class="highlight"><span class="nb">eapply</span> All_impl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?P</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk69"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
<span class="nl">?P</span> x -&gt; map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk6a"><span class="highlight"><span class="nb">eapply</span> All_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?P</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk6b"><hr></label><div class="goal-conclusion"><span class="highlight">All <span class="nl">?Q</span> l</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="Ast-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk6c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
(<span class="kr">fun</span> <span class="nv">x0</span> : def A =&gt; <span class="nl">?P</span> x0 * <span class="nl">?Q</span> x0) x -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk6d"><span class="highlight"><span class="bp">exact</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All <span class="nl">?Q</span> l</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Ast-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="Ast-v-chk6e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
(<span class="kr">fun</span> <span class="nv">x0</span> : def A =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : def A =&gt; P (dtype x1) * P&#39; (dbody x1)) x0 *
 <span class="nl">?Q</span> x0) x -&gt; map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk6f"><span class="highlight"><span class="bp">exact</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; test_def p p&#39; x) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
(<span class="kr">fun</span> <span class="nv">x0</span> : def A =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : def A =&gt; P (dtype x1) * P&#39; (dbody x1)) x0 *
 (<span class="kr">fun</span> <span class="nv">x1</span> : def A =&gt; is_true (test_def p p&#39; x1)) x0) x -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk70"><span class="highlight"><span class="nb">intros</span> [] [[] ?]; <span class="nb">unfold</span> map_def, test_def <span class="kr">in</span> *; <span class="nb">cbn</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt;
   P (BasicAst.dtype x) * P&#39; (BasicAst.dbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt;
   p (BasicAst.dtype x) &amp;&amp; p&#39; (BasicAst.dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dname</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dtype, dbody</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">rarg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P dtype</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39; dbody</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (p dtype &amp;&amp; p&#39; dbody)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
dname := dname;
dtype := f dtype;
dbody := f&#39; dbody;
rarg := rarg |} =
{|
dname := dname;
dtype := g dtype;
dbody := g&#39; dbody;
rarg := rarg |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Ast-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Ast-v-chk71"><span class="highlight">rtoProp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p, p'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt;
   P (BasicAst.dtype x) * P&#39; (BasicAst.dbody x)) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt;
   p (BasicAst.dtype x) &amp;&amp; p&#39; (BasicAst.dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; p x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; p&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dname</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dtype, dbody</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">rarg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P dtype</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39; dbody</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (p dtype)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (p&#39; dbody)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
dname := dname;
dtype := f dtype;
dbody := f&#39; dbody;
rarg := rarg |} =
{|
dname := dname;
dtype := g dtype;
dbody := g&#39; dbody;
rarg := rarg |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">apply_spec</span> :=
  <span class="kr">match goal with</span>
  | H : All _ _, H&#39; : forallb _ _ = _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (All_forallb_map_spec H H&#39;)
  | H : All _ _, H&#39; : forallb _ _ = _ |- forallb _ _ = _ =&gt;
    <span class="nb">eapply</span> (All_forallb_forallb_spec H H&#39;)
  | H : tCaseBrsProp _ _, H&#39; : forallb _ _ = _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (case_brs_forallb_map_spec H H&#39;)
  | H : All _ _, H&#39; : is_true (forallb _ _) |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (All_forallb_map_spec H H&#39;)
  | H : All _ _, H&#39; : is_true (forallb _ _) |- forallb _ _ = _ =&gt;
    <span class="nb">eapply</span> (All_forallb_forallb_spec H H&#39;)
  | H : tCaseBrsProp _ _, H&#39; : is_true (forallb _ _) |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (case_brs_forallb_map_spec H H&#39;)
  | H : tCaseBrsProp _ _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (case_brs_map_spec H)
  | H : tFixProp _ _ _, H&#39; : forallb _ _ = _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (tfix_forallb_map_spec H H&#39;)
  | H : tFixProp _ _ _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (tfix_map_spec H)
  | H : All _ _ |- map _ _ = map _ _ =&gt;
    <span class="nb">eapply</span> (All_map_eq H)
  | H : All _ _ |- map _ _ = _ =&gt;
    <span class="nb">eapply</span> (All_map_id H)
  | H : All _ _ |- is_true (forallb _ _) =&gt;
    <span class="nb">eapply</span> (All_forallb _ _ H); <span class="nb">clear</span> H
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">close_All</span> :=
  <span class="kr">match goal with</span>
  | H : Forall _ _ |- Forall _ _ =&gt; <span class="nb">apply</span> (Forall_impl H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : All _ _ |- All _ _ =&gt; <span class="nb">apply</span> (All_impl H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : OnOne2 _ _ _ |- OnOne2 _ _ _ =&gt; <span class="nb">apply</span> (OnOne2_impl H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : All2 _ _ _ |- All2 _ _ _ =&gt; <span class="nb">apply</span> (All2_impl H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : Forall2 _ _ _ |- Forall2 _ _ _ =&gt; <span class="nb">apply</span> (Forall2_impl H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : All _ _ |- All2 _ _ _ =&gt;
    <span class="nb">apply</span> (All_All2 H); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  | H : All2 _ _ _ |- All _ _ =&gt;
    (<span class="nb">apply</span> (All2_All_left H) || <span class="nb">apply</span> (All2_All_right H)); <span class="nb">clear</span> H; <span class="nb">simpl</span>
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">term</span> : <span class="kt">Type</span> :=
| tRel (n : nat)
| tVar (id : <span class="kn">ident</span>) <span class="c">(* For free variables (e.g. in a goal) *)</span>
| tEvar (ev : nat) (args : list term)
| tSort (s : <span class="kn">Universe</span>.t)
| tCast (t : term) (kind : cast_kind) (v : term)
| tProd (na : aname) (ty : term) (body : term)
| tLambda (na : aname) (ty : term) (body : term)
| tLetIn (na : aname) (def : term) (def_ty : term) (body : term)
| tApp (f : term) (args : list term)
| tConst (c : kername) (u : <span class="kn">Instance</span>.t)
| tInd (ind : inductive) (u : <span class="kn">Instance</span>.t)
| tConstruct (ind : inductive) (idx : nat) (u : <span class="kn">Instance</span>.t)
| tCase (ci : case_info) (type_info:predicate term)
        (discr:term) (branches : list (branch term))
| tProj (proj : projection) (t : term)
| tFix (mfix : mfixpoint term) (idx : nat)
| tCoFix (mfix : mfixpoint term) (idx : nat)
| tInt (i : Int63.int)
| tFloat (f : PrimFloat.float).</span></span></span></pre><div class="doc">
This can be used to represent holes, that, when unquoted, turn into fresh existential variables. 
    The fresh evar will depend on the whole context at this point in the term, despite the empty instance.
    Denotation will call Coq's Typing.solve_evars to try and fill these holes using typing information.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hole</span> := tEvar fresh_evar_id [].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mkApps</span> <span class="nv">t</span> <span class="nv">us</span> :=
  <span class="kr">match</span> us <span class="kr">with</span>
  | nil =&gt; t
  | _ =&gt; <span class="kr">match</span> t <span class="kr">with</span>
        | tApp f args =&gt; tApp f (args ++ us)
        | _ =&gt; tApp t us
        <span class="kr">end</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Term lifting / weakening 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">lift</span> <span class="nv">n</span> <span class="nv">k</span> <span class="nv">t</span> : term :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tRel i =&gt; tRel (<span class="kr">if</span> Nat.leb k i <span class="kr">then</span> n + i <span class="kr">else</span> i)
  | tEvar ev args =&gt; tEvar ev (List.map (lift n k) args)
  | tLambda na T M =&gt; tLambda na (lift n k T) (lift n (S k) M)
  | tApp u v =&gt; tApp (lift n k u) (List.map (lift n k) v)
  | tProd na A B =&gt; tProd na (lift n k A) (lift n (S k) B)
  | tCast c kind t =&gt; tCast (lift n k c) kind (lift n k t)
  | tLetIn na b t b&#39; =&gt; tLetIn na (lift n k b) (lift n k t) (lift n (S k) b&#39;)
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length (pcontext p) + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">p&#39;</span> := map_predicate id (lift n k) (lift n k&#39;) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := map_branches_k (lift n) k brs <span class="kr">in</span>
    tCase ind p&#39; (lift n k c) brs&#39;
  | tProj p c =&gt; tProj p (lift n k c)
  | tFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (lift n k) (lift n k&#39;)) mfix <span class="kr">in</span>
    tFix mfix&#39; idx
  | tCoFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (lift n k) (lift n k&#39;)) mfix <span class="kr">in</span>
    tCoFix mfix&#39; idx
  | x =&gt; x
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">lift0</span> n := (lift n <span class="mi">0</span>).</span></span></span></pre><div class="doc">
Parallel substitution: it assumes that all terms in the substitution live in the
    same context 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">subst</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">u</span> :=
  <span class="kr">match</span> u <span class="kr">with</span>
  | tRel n =&gt;
    <span class="kr">if</span> Nat.leb k n <span class="kr">then</span>
      <span class="kr">match</span> nth_error s (n - k) <span class="kr">with</span>
      | Some b =&gt; lift0 k b
      | None =&gt; tRel (n - List.length s)
      <span class="kr">end</span>
    <span class="kr">else</span> tRel n
  | tEvar ev args =&gt; tEvar ev (List.map (<span class="nb">subst</span> s k) args)
  | tLambda na T M =&gt; tLambda na (<span class="nb">subst</span> s k T) (<span class="nb">subst</span> s (S k) M)
  | tApp u v =&gt; mkApps (<span class="nb">subst</span> s k u) (List.map (<span class="nb">subst</span> s k) v)
  | tProd na A B =&gt; tProd na (<span class="nb">subst</span> s k A) (<span class="nb">subst</span> s (S k) B)
  | tCast c kind ty =&gt; tCast (<span class="nb">subst</span> s k c) kind (<span class="nb">subst</span> s k ty)
  | tLetIn na b ty b&#39; =&gt; tLetIn na (<span class="nb">subst</span> s k b) (<span class="nb">subst</span> s k ty) (<span class="nb">subst</span> s (S k) b&#39;)
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length (pcontext p) + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">p&#39;</span> := map_predicate id (<span class="nb">subst</span> s k) (<span class="nb">subst</span> s k&#39;) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := map_branches_k (<span class="nb">subst</span> s) k brs <span class="kr">in</span>
    tCase ind p&#39; (<span class="nb">subst</span> s k c) brs&#39;
  | tProj p c =&gt; tProj p (<span class="nb">subst</span> s k c)
  | tFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (<span class="nb">subst</span> s k) (<span class="nb">subst</span> s k&#39;)) mfix <span class="kr">in</span>
    tFix mfix&#39; idx
  | tCoFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (<span class="nb">subst</span> s k) (<span class="nb">subst</span> s k&#39;)) mfix <span class="kr">in</span>
    tCoFix mfix&#39; idx
  | x =&gt; x
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Substitutes <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode">;</span> <span class="inlinecode">..</span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="var">tn</span></span> in u for <span class="inlinecode"><span class="id" title="var">Rel</span></span> <span class="inlinecode">0;</span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">Rel</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>-1)</span> *in parallel* 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">subst0</span> t := (<span class="nb">subst</span> t <span class="mi">0</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subst1</span> <span class="nv">t</span> <span class="nv">k</span> <span class="nv">u</span> := <span class="nb">subst</span> [t] k u.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">subst10</span> t := (subst1 t <span class="mi">0</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;M { j := N }&quot;</span> := (subst1 N j M) (<span class="kn">at level</span> <span class="mi">10</span>, <span class="kn">right associativity</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">closedn</span> <span class="nv">k</span> (<span class="nv">t</span> : term) : bool :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tRel i =&gt; Nat.ltb i k
  | tEvar ev args =&gt; List.forallb (closedn k) args
  | tLambda _ T M | tProd _ T M =&gt; closedn k T &amp;&amp; closedn (S k) M
  | tApp u v =&gt; closedn k u &amp;&amp; List.forallb (closedn k) v
  | tCast c kind t =&gt; closedn k c &amp;&amp; closedn k t
  | tLetIn na b t b&#39; =&gt; closedn k b &amp;&amp; closedn k t &amp;&amp; closedn (S k) b&#39;
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length (pcontext p) + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">p&#39;</span> := test_predicate (<span class="kr">fun</span> <span class="nv">_</span> =&gt; true) (closedn k) (closedn k&#39;) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := test_branches_k closedn k brs <span class="kr">in</span>
    p&#39; &amp;&amp; closedn k c &amp;&amp; brs&#39;
  | tProj p c =&gt; closedn k c
  | tFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    List.forallb (test_def (closedn k) (closedn k&#39;)) mfix
  | tCoFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    List.forallb (test_def (closedn k) (closedn k&#39;)) mfix
  | x =&gt; true
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">closed</span> t := (closedn <span class="mi">0</span> t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">noccur_between</span> <span class="nv">k</span> <span class="nv">n</span> (<span class="nv">t</span> : term) : bool :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tRel i =&gt; Nat.ltb i k &amp;&amp; Nat.leb (k + n) i
  | tEvar ev args =&gt; List.forallb (noccur_between k n) args
  | tLambda _ T M | tProd _ T M =&gt; noccur_between k n T &amp;&amp; noccur_between (S k) n M
  | tApp u v =&gt; noccur_between k n u &amp;&amp; List.forallb (noccur_between k n) v
  | tCast c kind t =&gt; noccur_between k n c &amp;&amp; noccur_between k n t
  | tLetIn na b t b&#39; =&gt; noccur_between k n b &amp;&amp; noccur_between k n t &amp;&amp; noccur_between (S k) n b&#39;
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length (pcontext p) + k <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">p&#39;</span> := test_predicate (<span class="kr">fun</span> <span class="nv">_</span> =&gt; true) (noccur_between k n) (noccur_between k&#39; n) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := test_branches_k (<span class="kr">fun</span> <span class="nv">k</span> =&gt; noccur_between k n) k brs <span class="kr">in</span>
    p&#39; &amp;&amp; noccur_between k n c &amp;&amp; brs&#39;
  | tProj p c =&gt; noccur_between k n c
  | tFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    List.forallb (test_def (noccur_between k n) (noccur_between k&#39; n)) mfix
  | tCoFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">k&#39;</span> := List.length mfix + k <span class="kr">in</span>
    List.forallb (test_def (noccur_between k n) (noccur_between k&#39; n)) mfix
  | x =&gt; true
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">subst_instance_constr</span> : UnivSubst term :=
  <span class="kr">fix</span> subst_instance_constr u c {<span class="kr">struct</span> c} : term :=
  <span class="kr">match</span> c <span class="kr">with</span>
  | tRel _ | tVar _  | tInt _ | tFloat _ =&gt; c
  | tEvar ev args =&gt; tEvar ev (List.map (subst_instance_constr u) args)
  | tSort s =&gt; tSort (subst_instance_univ u s)
  | tConst c u&#39; =&gt; tConst c (subst_instance_instance u u&#39;)
  | tInd i u&#39; =&gt; tInd i (subst_instance_instance u u&#39;)
  | tConstruct ind k u&#39; =&gt; tConstruct ind k (subst_instance_instance u u&#39;)
  | tLambda na T M =&gt; tLambda na (subst_instance_constr u T) (subst_instance_constr u M)
  | tApp f v =&gt; tApp (subst_instance_constr u f) (List.map (subst_instance_constr u) v)
  | tProd na A B =&gt; tProd na (subst_instance_constr u A) (subst_instance_constr u B)
  | tCast c kind ty =&gt; tCast (subst_instance_constr u c) kind (subst_instance_constr u ty)
  | tLetIn na b ty b&#39; =&gt; tLetIn na (subst_instance_constr u b) (subst_instance_constr u ty)
                                (subst_instance_constr u b&#39;)
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">p&#39;</span> := map_predicate (subst_instance_instance u) (subst_instance_constr u) (subst_instance_constr u) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := List.map (map_branch (subst_instance_constr u)) brs <span class="kr">in</span>
    tCase ind p&#39; (subst_instance_constr u c) brs&#39;
  | tProj p c =&gt; tProj p (subst_instance_constr u c)
  | tFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (subst_instance_constr u) (subst_instance_constr u)) mfix <span class="kr">in</span>
    tFix mfix&#39; idx
  | tCoFix mfix idx =&gt;
    <span class="kr">let</span> <span class="nv">mfix&#39;</span> := List.map (map_def (subst_instance_constr u) (subst_instance_constr u)) mfix <span class="kr">in</span>
    tCoFix mfix&#39; idx
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Tests that the term is closed over <span class="inlinecode"><span class="id" title="var">k</span></span> universe variables 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">closedu</span> (<span class="nv">k</span> : nat) (<span class="nv">t</span> : term) : bool :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tSort univ =&gt; closedu_universe k univ
  | tInd _ u =&gt; closedu_instance k u
  | tConstruct _ _ u =&gt; closedu_instance k u
  | tConst _ u =&gt; closedu_instance k u
  | tRel i =&gt; true
  | tEvar ev args =&gt; forallb (closedu k) args
  | tLambda _ T M | tProd _ T M =&gt; closedu k T &amp;&amp; closedu k M
  | tApp u v =&gt; closedu k u &amp;&amp; forallb (closedu k) v
  | tCast c kind t =&gt; closedu k c &amp;&amp; closedu k t
  | tLetIn na b t b&#39; =&gt; closedu k b &amp;&amp; closedu k t &amp;&amp; closedu k b&#39;
  | tCase ind p c brs =&gt;
    <span class="kr">let</span> <span class="nv">p&#39;</span> := test_predicate (closedu_instance k) (closedu k) (closedu k) p <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">brs&#39;</span> := forallb (test_branch (closedu k)) brs <span class="kr">in</span>
    p&#39; &amp;&amp; closedu k c &amp;&amp; brs&#39;
  | tProj p c =&gt; closedu k c
  | tFix mfix idx =&gt;
    forallb (test_def (closedu k) (closedu k)) mfix
  | tCoFix mfix idx =&gt;
    forallb (test_def (closedu k) (closedu k)) mfix
  | x =&gt; true
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">  
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">TemplateTerm</span> &lt;: Term.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">term</span> := term.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tRel</span> := tRel.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tSort</span> := tSort.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tProd</span> := tProd.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tLambda</span> := tLambda.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tLetIn</span> := tLetIn.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tInd</span> := tInd.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tProj</span> := tProj.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mkApps</span> := mkApps.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lift</span> := lift.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subst</span> := <span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">closedn</span> := closedn.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">noccur_between</span> := noccur_between.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">subst_instance_constr</span> := subst_instance.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">TemplateTerm</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">unf_term</span> := <span class="nb">unfold</span> TemplateTerm.term <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.tRel <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.tSort <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.tProd <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.tLambda <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.tLetIn <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.tInd <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.tProj <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.lift <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.<span class="nb">subst</span> <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.closedn <span class="kr">in</span> *; <span class="nb">unfold</span> TemplateTerm.noccur_between <span class="kr">in</span> *;
                 <span class="nb">unfold</span> TemplateTerm.subst_instance_constr <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">                 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Env</span> := Environment TemplateTerm.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Export</span> Env.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Do NOT `Include` this module, as this would sadly duplicate the rewrite database... *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mkApp</span> <span class="nv">t</span> <span class="nv">u</span> := <span class="kn">Eval</span> <span class="nb">cbn</span> <span class="kr">in</span> mkApps t [u].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isApp</span> <span class="nv">t</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tApp _ _ =&gt; true
  | _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isLambda</span> <span class="nv">t</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tLambda _ _ _ =&gt; true
  | _ =&gt; false
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Well-formed terms: invariants which are not ensured by the OCaml type system 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">wf</span> : term -&gt; <span class="kt">Prop</span> :=
| wf_tRel n : <span class="kn">wf</span> (tRel n)
| wf_tVar id : <span class="kn">wf</span> (tVar id)
| wf_tEvar n l : Forall <span class="kn">wf</span> l -&gt; <span class="kn">wf</span> (tEvar n l)
| wf_tSort u : <span class="kn">wf</span> (tSort u)
| wf_tCast t k t&#39; : <span class="kn">wf</span> t -&gt; <span class="kn">wf</span> t&#39; -&gt; <span class="kn">wf</span> (tCast t k t&#39;)
| wf_tProd na t b : <span class="kn">wf</span> t -&gt; <span class="kn">wf</span> b -&gt; <span class="kn">wf</span> (tProd na t b)
| wf_tLambda na t b : <span class="kn">wf</span> t -&gt; <span class="kn">wf</span> b -&gt; <span class="kn">wf</span> (tLambda na t b)
| wf_tLetIn na t b b&#39; : <span class="kn">wf</span> t -&gt; <span class="kn">wf</span> b -&gt; <span class="kn">wf</span> b&#39; -&gt; <span class="kn">wf</span> (tLetIn na t b b&#39;)
| wf_tApp t u : isApp t = false -&gt; u &lt;&gt; nil -&gt; <span class="kn">wf</span> t -&gt; Forall <span class="kn">wf</span> u -&gt; <span class="kn">wf</span> (tApp t u)
| wf_tConst k u : <span class="kn">wf</span> (tConst k u)
| wf_tInd i u : <span class="kn">wf</span> (tInd i u)
| wf_tConstruct i k u : <span class="kn">wf</span> (tConstruct i k u)
| wf_tCase ci p c brs :
    Forall <span class="kn">wf</span> (pparams p) -&gt; <span class="kn">wf</span> (preturn p) -&gt;
    <span class="kn">wf</span> c -&gt;
    Forall (<span class="kn">wf</span> ‚àò bbody) brs -&gt;
    <span class="kn">wf</span> (tCase ci p c brs)
| wf_tProj p t : <span class="kn">wf</span> t -&gt; <span class="kn">wf</span> (tProj p t)
| wf_tFix mfix k : Forall (<span class="kr">fun</span> <span class="nv">def</span> =&gt; <span class="kn">wf</span> def.(dtype) /\ <span class="kn">wf</span> def.(dbody)) mfix -&gt;
                   <span class="kn">wf</span> (tFix mfix k)
| wf_tCoFix mfix k : Forall (<span class="kr">fun</span> <span class="nv">def</span> =&gt; <span class="kn">wf</span> def.(dtype) /\ <span class="kn">wf</span> def.(dbody)) mfix -&gt; <span class="kn">wf</span> (tCoFix mfix k)
| wf_tInt i : <span class="kn">wf</span> (tInt i)
| wf_tFloat f : <span class="kn">wf</span> (tFloat f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">Signature</span> <span class="kr">for</span> <span class="kn">wf</span>.</span></span></span></pre><div class="doc">
<a name="lab6"></a><h2 class="section">Entries</h2>
<div class="paragraph"> </div>

  The kernel accepts these inputs and typechecks them to produce
  declarations. Reflects <span class="inlinecode"><span class="id" title="var">kernel</span>/<span class="id" title="var">entries.mli</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --></pre><div class="doc">
<a name="lab7"></a><h3 class="section">Constant and axiom entries</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">parameter_entry</span> := {
  parameter_entry_type      : term;
  parameter_entry_universes : universes_entry }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">definition_entry</span> := {
  definition_entry_type      : option term;
  definition_entry_body      : term;
  definition_entry_universes : universes_entry;
  definition_entry_opaque    : bool }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">constant_entry</span> :=
| ParameterEntry  (p : parameter_entry)
| DefinitionEntry (def : definition_entry).</span></span></span></pre><div class="doc">
<a name="lab8"></a><h3 class="section">Inductive entries</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --></pre><div class="doc">
This is the representation of mutual inductives.
    nearly copied from <span class="inlinecode"><span class="id" title="var">kernel</span>/<span class="id" title="var">entries.mli</span></span>
<div class="paragraph"> </div>

  Assume the following definition in concrete syntax:

<div class="paragraph"> </div>
<br/>
<span class="inlinecode">¬†¬†<span class="id" title="keyword">Inductive</span> <span class="id" title="var">I1</span> (<span class="id" title="var">x1</span>:<span class="id" title="var">X1</span>) ... (<span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span>) : <span class="id" title="var">A1</span> := <span class="id" title="var">c11</span> : <span class="id" title="var">T11</span> | ... | <span class="id" title="var">c1n1</span> : <span class="id" title="var">T1n1</span><br/>
¬†¬†...<br/>
¬†¬†<span class="id" title="keyword">with</span> <span class="id" title="var">Ip</span> (<span class="id" title="var">x1</span>:<span class="id" title="var">X1</span>) ... (<span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span>) : <span class="id" title="var">Ap</span> := <span class="id" title="var">cp1</span> : <span class="id" title="var">Tp1</span>  ... | <span class="id" title="var">cpnp</span> : <span class="id" title="var">Tpnp</span>.
<div class="paragraph"> </div>
</span>
<div class="paragraph"> </div>

  then, in <span class="inlinecode"><span class="id" title="var">i</span></span>th block, <span class="inlinecode"><span class="id" title="var">mind_entry_params</span></span> is <span class="inlinecode"><span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span>;...;<span class="id" title="var">x1</span>:<span class="id" title="var">X1</span></span>;
  <span class="inlinecode"><span class="id" title="var">mind_entry_arity</span></span> is <span class="inlinecode"><span class="id" title="var">Ai</span></span>, defined in context <span class="inlinecode"><span class="id" title="var">x1</span>:<span class="id" title="var">X1</span>;...;<span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span></span>;
  <span class="inlinecode"><span class="id" title="var">mind_entry_lc</span></span> is <span class="inlinecode"><span class="id" title="var">Ti1</span>;...;<span class="id" title="var">Tini</span></span>, defined in context
  <span class="inlinecode"><span class="id" title="var">A'1</span>;...;<span class="id" title="var">A'p</span>;<span class="id" title="var">x1</span>:<span class="id" title="var">X1</span>;...;<span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span></span> where <span class="inlinecode"><span class="id" title="var">A'i</span></span> is <span class="inlinecode"><span class="id" title="var">Ai</span></span> generalized over
  <span class="inlinecode"><span class="id" title="var">x1</span>:<span class="id" title="var">X1</span>;...;<span class="id" title="var">xn</span>:<span class="id" title="var">Xn</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">one_inductive_entry</span> := {
  mind_entry_typename : <span class="kn">ident</span>;
  mind_entry_arity : term;
  mind_entry_template : bool; <span class="c">(* template polymorphism *)</span>
  mind_entry_consnames : list <span class="kn">ident</span>;
  mind_entry_lc : list term <span class="c">(* constructor list *)</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">mutual_inductive_entry</span> := {
  mind_entry_record    : option (option <span class="kn">ident</span>);
  <span class="c">(* Is this mutual inductive defined as a record?</span>
<span class="c">     If so, is it primitive, using binder name [ident]</span>
<span class="c">     for the record in primitive projections ? *)</span>
  mind_entry_finite    : recursivity_kind;
  mind_entry_params    : <span class="kp">context</span>;
  mind_entry_inds      : list one_inductive_entry;
  mind_entry_universes : universes_entry;
  mind_entry_variance  : option (list Universes.Variance.t);
  mind_entry_private   : option bool
  <span class="c">(* Private flag for sealing an inductive definition in an enclosing</span>
<span class="c">     module. Not handled by Template Coq yet. *)</span> }.</span></span></span></pre><div class="doc">
Helpers for "compact" case representation, reconstructing predicate and 
  branch contexts. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_predicate_context</span> <span class="nv">ind</span> <span class="nv">mdecl</span> <span class="nv">idecl</span> <span class="nv">params</span> <span class="nv">puinst</span> <span class="nv">pctx</span> : <span class="kp">context</span> :=
  <span class="kr">let</span> <span class="nv">indty</span> := mkApps (tInd ind puinst) (map (lift0 #|idecl.(ind_indices)|) params ++ to_extended_list idecl.(ind_indices)) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">inddecl</span> := 
    {| decl_name := 
      {| binder_name := nNamed (ind_name idecl); binder_relevance := idecl.(ind_relevance) |};
        decl_body := None;
        decl_type := indty |}
  <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ictx</span> := 
    subst_context params <span class="mi">0</span>
      (subst_instance puinst (expand_lets_ctx mdecl.(ind_params) idecl.(ind_indices)))
  <span class="kr">in</span>
  map2 set_binder_name pctx (inddecl :: ictx).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branch_context_gen</span> <span class="nv">params</span> <span class="nv">puinst</span> <span class="nv">cdecl</span> : <span class="kp">context</span> :=
  subst_context params <span class="mi">0</span> (subst_instance puinst cdecl.(cstr_args)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branch_context</span> <span class="nv">p</span> <span class="nv">cdecl</span> : <span class="kp">context</span> :=
  case_branch_context_gen p.(pparams) p.(puinst) cdecl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branches_contexts_gen</span> <span class="nv">idecl</span> <span class="nv">params</span> <span class="nv">puinst</span> : list <span class="kp">context</span> :=
  map (case_branch_context_gen params puinst) idecl.(ind_ctors).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branches_contexts</span> <span class="nv">idecl</span> <span class="nv">p</span> : list <span class="kp">context</span> :=
  map (case_branch_context_gen p.(pparams) p.(puinst)) idecl.(ind_ctors).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branch_type_gen</span> <span class="nv">ind</span> <span class="nv">params</span> <span class="nv">puinst</span> <span class="nv">ptm</span> <span class="nv">i</span> <span class="nv">cdecl</span> : <span class="kp">context</span> * term :=
  <span class="kr">let</span> <span class="nv">cstr</span> := tConstruct ind i puinst <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := to_extended_list cdecl.(cstr_args) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">cstrapp</span> := mkApps cstr (map (lift0 #|cdecl.(cstr_args)|) params ++ args) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">brctx</span> := subst_context params <span class="mi">0</span> (subst_instance puinst cdecl.(cstr_args)) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ty</span> := mkApps (lift0 #|cdecl.(cstr_args)| ptm) (cdecl.(cstr_indices) ++ [cstrapp]) <span class="kr">in</span>
  (brctx, ty).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branches_types_gen</span> <span class="nv">ind</span> <span class="nv">idecl</span> <span class="nv">params</span> <span class="nv">puinst</span> <span class="nv">ptm</span> : list (<span class="kp">context</span> * term) :=
  mapi (case_branch_type_gen ind params puinst ptm) idecl.(ind_ctors).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">case_branches_types</span> <span class="nv">ind</span> <span class="nv">idecl</span> <span class="nv">p</span> <span class="nv">ptm</span> : list (<span class="kp">context</span> * term) :=
  mapi (case_branch_type_gen ind p.(pparams) p.(puinst) ptm) idecl.(ind_ctors).</span></span></span></pre></article></body></html>