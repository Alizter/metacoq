<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>BasicAst.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.11.0+0.11.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Distributed under the terms of the MIT license. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect Morphisms Setoid.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Import</span> utils.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require</span> Floats.SpecFloat.</span></span></span></pre><div class="doc">
<a name="lab1"></a><h2 class="section">Reification of names **</h2>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">Comment</span></span> <span class="inlinecode"><span class="id" title="var">taken</span></span> <span class="inlinecode"><span class="id" title="var">from</span></span> <span class="inlinecode"><span class="id" title="var">Coq's</span></span> <span class="inlinecode"><span class="id" title="var">code</span></span>
<ul class="doclist">
<li> Id.t is the type of identifiers, that is morally a subset of strings which
      only contains Unicode characters of the Letter kind (and a few more).
      =&gt; <span class="inlinecode"><span class="id" title="var">ident</span></span>
</li>
<li> Name.t is an ad-hoc variant of Id.t option allowing to handle optionally
      named objects.
      =&gt; <span class="inlinecode"><span class="id" title="var">name</span></span>
</li>
<li> DirPath.t represents generic paths as sequences of identifiers.
      =&gt; <span class="inlinecode"><span class="id" title="var">dirpath</span></span>
</li>
<li> Label.t is an equivalent of Id.t made distinct for semantical purposes.
      =&gt; <span class="inlinecode"><span class="id" title="var">ident</span></span>
</li>
<li> ModPath.t are module paths.
      =&gt; <span class="inlinecode"><span class="id" title="var">modpath</span></span>
</li>
<li> KerName.t are absolute names of objects in Coq.
      =&gt; <span class="inlinecode"><span class="id" title="var">kername</span></span>
</li>
</ul>
<div class="paragraph"> </div>

    And also :
<ul class="doclist">
<li> Constant.t =&gt; <span class="inlinecode"><span class="id" title="var">kername</span></span>
</li>
<li> variable =&gt; <span class="inlinecode"><span class="id" title="var">ident</span></span>
</li>
<li> MutInd.t =&gt; <span class="inlinecode"><span class="id" title="var">kername</span></span>
</li>
<li> inductive =&gt; <span class="inlinecode"><span class="id" title="var">inductive</span></span>
</li>
<li> constructor =&gt; <span class="inlinecode"><span class="id" title="var">inductive</span></span> <span class="inlinecode">√ó</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>
</li>
<li> Projection.t =&gt; <span class="inlinecode"><span class="id" title="var">projection</span></span>
</li>
<li> GlobRef.t =&gt; global_reference

</li>
</ul>
<div class="paragraph"> </div>

    Finally, we define the models of primitive types (uint63 and floats64).

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ident</span>   := string. <span class="c">(* e.g. nat *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">qualid</span>  := string. <span class="c">(* e.g. Datatypes.nat *)</span></span></span></span></pre><div class="doc">
Type of directory paths. Essentially a list of module identifiers. The
    order is reversed to improve sharing. E.g. A.B.C is <span class="inlinecode">"<span class="id" title="var">C</span>";"<span class="id" title="var">B</span>";"<span class="id" title="var">A</span>"</span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">dirpath</span> := list <span class="kn">ident</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">dirpath_eqdec</span> : Classes.EqDec dirpath := _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_dirpath</span> : dirpath -&gt; string
  := String.concat <span class="s2">&quot;.&quot;</span> ‚àò rev.</span></span></span></pre><div class="doc">
The module part of the kernel name.
<ul class="doclist">
<li> MPfile is for toplevel libraries, i.e. .vo files

</li>
<li> MPbound are parameters of functors

</li>
<li> MPdot is for submodules

</li>
</ul>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">modpath</span> :=
| MPfile  (dp : dirpath)
| MPbound (dp : dirpath) (id : <span class="kn">ident</span>) (i : nat)
| MPdot   (mp : modpath) (id : <span class="kn">ident</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> modpath.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">string_of_modpath</span> (<span class="nv">mp</span> : modpath) : string :=
  <span class="kr">match</span> mp <span class="kr">with</span>
  | MPfile dp =&gt; string_of_dirpath dp
  | MPbound dp id _ =&gt; string_of_dirpath dp ^ <span class="s2">&quot;.&quot;</span> ^ id
  | MPdot mp id =&gt; string_of_modpath mp ^ <span class="s2">&quot;.&quot;</span> ^ id
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
The absolute names of objects seen by kernel 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">kername</span> := modpath √ó <span class="kn">ident</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">kername_eqdec</span> : Classes.EqDec kername := _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_kername</span> (<span class="nv">kn</span> : kername) :=
  string_of_modpath kn.<span class="mi">1</span> ^ <span class="s2">&quot;.&quot;</span> ^ kn.<span class="mi">2</span>.</span></span></span></pre><div class="doc">
Identifiers that are allowed to be anonymous (i.e. "_" in concrete syntax). 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">name</span> : <span class="kt">Set</span> :=
| nAnon
| nNamed (_ : <span class="kn">ident</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> name.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">relevance</span> : <span class="kt">Set</span> := Relevant | Irrelevant.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> relevance.</span></span></span></pre><div class="doc">
Binders annotated with relevance 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">binder_annot</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := mkBindAnn { binder_name : A; binder_relevance : relevance }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> mkBindAnn {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> binder_name {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> binder_relevance {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> binder_annot.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk0"><span class="highlight"><span class="kn">Instance</span> <span class="nf">eqdec_binder_annot</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">e</span> : Classes.EqDec A) : Classes.EqDec (binder_annot A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Classes.EqDec A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec (binder_annot A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Classes.EqDec A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec (binder_annot A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">ltac</span>:(Equations.<span class="kt">Prop</span>.Tactics.eqdec_proof).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_binder_annot</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : binder_annot A) : binder_annot B :=
  {| binder_name := f b.(binder_name); binder_relevance := b.(binder_relevance) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_binder_annot</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">b</span> : binder_annot A) (<span class="nv">b&#39;</span> : binder_annot B) : <span class="kt">Prop</span> :=
  b.(binder_relevance) = b&#39;.(binder_relevance).</span></span></span></pre><div class="doc">
Type of annotated names 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">aname</span> := binder_annot name.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">anqme_eqdec</span> : Classes.EqDec aname := _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eqb_binder_annot</span> {<span class="nv">A</span>} (<span class="nv">b</span> <span class="nv">b&#39;</span> : binder_annot A) : bool :=
  <span class="kr">match</span> Classes.eq_dec b.(binder_relevance) b&#39;.(binder_relevance) <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt; true
  | <span class="nb">right</span> _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_name</span> (<span class="nv">na</span> : name) :=
  <span class="kr">match</span> na <span class="kr">with</span>
  | nAnon =&gt; <span class="s2">&quot;_&quot;</span>
  | nNamed n =&gt; n
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_relevance</span> (<span class="nv">r</span> : relevance) :=
  <span class="kr">match</span> r <span class="kr">with</span>
  | Relevant =&gt; <span class="s2">&quot;Relevant&quot;</span>
  | Irrelevant =&gt; <span class="s2">&quot;Irrelevant&quot;</span>
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Designation of a (particular) inductive type. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">inductive</span> : <span class="kt">Set</span> := mkInd { inductive_mind : kername ;
                                  inductive_ind : nat }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> mkInd _%string _%nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> inductive.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_inductive</span> (<span class="nv">i</span> : inductive) :=
  string_of_kername (inductive_mind i) ^ <span class="s2">&quot;,&quot;</span> ^ string_of_nat (inductive_ind i).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">projection</span> : <span class="kt">Set</span> := inductive * nat <span class="c">(* params *)</span> * nat <span class="c">(* argument *)</span>.</span></span></span></pre><div class="doc">
Kernel declaration references <span class="inlinecode"><span class="id" title="var">global_reference</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">global_reference</span> :=
| VarRef : <span class="kn">ident</span> -&gt; global_reference
| ConstRef : kername -&gt; global_reference
| IndRef : inductive -&gt; global_reference
| ConstructRef : inductive -&gt; nat -&gt; global_reference.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> global_reference.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_gref</span> <span class="nv">gr</span> : string :=
  <span class="kr">match</span> gr <span class="kr">with</span>
  | VarRef v =&gt; v
  | ConstRef s =&gt; string_of_kername s
  | IndRef (mkInd s n) =&gt;
    <span class="s2">&quot;Inductive &quot;</span> ^ string_of_kername s ^ <span class="s2">&quot; &quot;</span> ^ (string_of_nat n)
  | ConstructRef (mkInd s n) k =&gt;
    <span class="s2">&quot;Constructor &quot;</span> ^ string_of_kername s ^ <span class="s2">&quot; &quot;</span> ^ (string_of_nat n) ^ <span class="s2">&quot; &quot;</span> ^ (string_of_nat k)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">kername_eq_dec</span> (<span class="nv">k</span> <span class="nv">k0</span> : kername) : {k = k0} + {k &lt;&gt; k0} := Classes.eq_dec k k0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> kername_eq_dec : eq_dec.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">gref_eq_dec</span> (<span class="nv">gr</span> <span class="nv">gr&#39;</span> : global_reference) : {gr = gr&#39;} + {~ gr = gr&#39;} := Classes.eq_dec gr gr&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ident_eq</span> (<span class="nv">x</span> <span class="nv">y</span> : ident) :=
  <span class="kr">match</span> string_compare x y <span class="kr">with</span>
  | Eq =&gt; true
  | _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ident_eq_spec</span> <span class="nv">x</span> <span class="nv">y</span> : reflect (x = y) (ident_eq x y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (x = y) (ident_eq x y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (x = y) (ident_eq x y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4"><span class="highlight"><span class="nb">unfold</span> ident_eq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (x = y)
  <span class="kr">match</span> string_compare x y <span class="kr">with</span>
  | Eq =&gt; true
  | _ =&gt; false
  <span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5"><span class="highlight"><span class="nb">destruct</span> (string_compare_eq x y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">string_compare x y = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y -&gt; string_compare x y = Eq</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (x = y)
  <span class="kr">match</span> string_compare x y <span class="kr">with</span>
  | Eq =&gt; true
  | _ =&gt; false
  <span class="kr">end</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6"><span class="highlight"><span class="nb">destruct</span> string_compare; <span class="nb">constructor</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y -&gt; Lt = Eq</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Gt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y -&gt; Gt = Eq</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk7"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk8"><span class="highlight"><span class="nb">intro</span> Heq; <span class="nb">specialize</span> (H0 Heq).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lt = Eq</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Gt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y -&gt; Gt = Eq</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk9"><hr></label><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka"><span class="highlight"><span class="bp">discriminate</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Gt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y -&gt; Gt = Eq</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkb"><span class="highlight"><span class="nb">intro</span> Heq; <span class="nb">specialize</span> (H0 Heq).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kn">ident</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Gt = Eq -&gt; x = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Gt = Eq</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">False</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">discriminate</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* todo : better ? *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_kername</span> (<span class="nv">k</span> <span class="nv">k0</span> : kername) : bool :=
  <span class="kr">match</span> kername_eq_dec k k0 <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt; true
  | <span class="nb">right</span> _ =&gt; false
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkc"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_kername_refl</span> <span class="nv">kn</span> : eq_kername kn kn.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_kername kn kn)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_kername kn kn)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chke"><span class="highlight"><span class="nb">unfold</span> eq_kername.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (<span class="kr">if</span> kername_eq_dec kn kn <span class="kr">then</span> true <span class="kr">else</span> false)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkf"><span class="highlight"><span class="nb">destruct</span> (kername_eq_dec kn kn); cbnr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">kn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kn &lt;&gt; kn</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_inductive</span> <span class="nv">i</span> <span class="nv">i&#39;</span> :=
  <span class="kr">let</span> <span class="nv">&#39;mkInd</span> <span class="nv">i</span> <span class="nv">n</span> := i <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">&#39;mkInd</span> <span class="nv">i&#39;</span> <span class="nv">n&#39;</span> := i&#39; <span class="kr">in</span>
  eq_kername i i&#39; &amp;&amp; Nat.eqb n n&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_constant</span> := eq_kername.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_projection</span> <span class="nv">p</span> <span class="nv">p&#39;</span> :=
  <span class="kr">let</span> &#39;(ind, pars, arg) := p <span class="kr">in</span>
  <span class="kr">let</span> &#39;(ind&#39;, pars&#39;, arg&#39;) := p&#39; <span class="kr">in</span>
  eq_inductive ind ind&#39; &amp;&amp; Nat.eqb pars pars&#39; &amp;&amp; Nat.eqb arg arg&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_inductive_refl</span> <span class="nv">i</span> : eq_inductive i i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_inductive i i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_inductive i i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk12"><span class="highlight"><span class="nb">destruct</span> i <span class="kr">as</span> [mind k].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true
  (eq_inductive
     {| inductive_mind := mind; inductive_ind := k |}
     {| inductive_mind := mind; inductive_ind := k |})</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk13"><span class="highlight"><span class="nb">unfold</span> eq_inductive.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">kername</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_kername mind mind &amp;&amp; (k =? k))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> eq_kername_refl PeanoNat.Nat.eqb_refl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk14"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eq_projection_refl</span> <span class="nv">i</span> : eq_projection i i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(inductive √ó nat) * nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_projection i i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(inductive √ó nat) * nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_projection i i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk16"><span class="highlight"><span class="nb">destruct</span> i <span class="kr">as</span> [[mind k] p].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k, p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (eq_projection (mind, k, p) (mind, k, p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk17"><span class="highlight"><span class="nb">unfold</span> eq_projection.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mind</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inductive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k, p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true
  (eq_inductive mind mind &amp;&amp; (k =? k) &amp;&amp; (p =? p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> eq_inductive_refl !PeanoNat.Nat.eqb_refl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
The kind of a cast 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">cast_kind</span> : <span class="kt">Set</span> :=
| VmCast
| NativeCast
| Cast
| RevertCast.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> cast_kind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">case_info</span> := mk_case_info { 
  ci_ind : inductive; 
  ci_npar : nat; 
  <span class="c">(* Not implemented yet, as the representation in PCUIC doesn&#39;t need this cached information.</span>
<span class="c">     ci_cstr_nargs : list nat; (* The number of REAL arguments of each constructor (no params, no lets) *)</span>
<span class="c">     ci_cstr_ndecls : list nat; (* The number of arguments of each constructor (no params but lets included) *)   *)</span>
  ci_relevance : relevance }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> case_info.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_case_info</span> <span class="nv">ci</span> := 
  <span class="s2">&quot;(&quot;</span> ^ string_of_inductive ci.(ci_ind) ^ <span class="s2">&quot;,&quot;</span> ^
  string_of_nat ci.(ci_npar) ^ <span class="s2">&quot;,&quot;</span> ^
  <span class="c">(* string_of_list string_of_nat ci.(ci_cstr_nargs) ^ &quot;,&quot; ^</span>
<span class="c">  string_of_list string_of_nat ci.(ci_cstr_ndecls) ^ &quot;,&quot; ^ *)</span>
  string_of_relevance ci.(ci_relevance) ^ <span class="s2">&quot;)&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">recursivity_kind</span> :=
  | Finite <span class="c">(* = inductive *)</span>
  | CoFinite <span class="c">(* = coinductive *)</span>
  | BiFinite <span class="c">(* = non-recursive, like in &quot;Record&quot; definitions *)</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> recursivity_kind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* The kind of a conversion problem *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">conv_pb</span> :=
  | Conv
  | Cumul.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> EqDec <span class="kr">for</span> conv_pb.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* This opaque natural number is a hack to inform unquoting to generate</span>
<span class="c">  a fresh evar when encountering it. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk18"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fresh_evar_id</span> : nat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> <span class="mi">0</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Parametrized by term because term is not yet defined *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">def</span> <span class="nv">term</span> := mkdef {
  dname : aname; <span class="c">(* the name, annotated with relevance **)</span>
  dtype : term;
  dbody : term; <span class="c">(* the body (a lambda term). Note, this may mention other (mutually-defined) names **)</span>
  rarg  : nat  <span class="c">(* the index of the recursive argument, 0 for cofixpoints **)</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> dname {term} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> dtype {term} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> dbody {term} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> rarg {term} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> def.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk19"><span class="highlight"><span class="kn">Instance</span> <span class="nf">def_eq_dec</span> {<span class="nv">A</span>} : Classes.EqDec A -&gt; Classes.EqDec (def A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec A -&gt; Classes.EqDec (def A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Classes.EqDec A -&gt; Classes.EqDec (def A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">ltac</span>:(Equations.<span class="kt">Prop</span>.Tactics.eqdec_proof).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">string_of_def</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; string) (<span class="nv">def</span> : def A) :=
  <span class="s2">&quot;(&quot;</span> ^ string_of_name (binder_name (dname def))
      ^ <span class="s2">&quot;,&quot;</span> ^ string_of_relevance (binder_relevance (dname def))
      ^ <span class="s2">&quot;,&quot;</span> ^ f (dtype def)
      ^ <span class="s2">&quot;,&quot;</span> ^ f (dbody def)
      ^ <span class="s2">&quot;,&quot;</span> ^ string_of_nat (rarg def) ^ <span class="s2">&quot;)&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">print_def</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; string) (<span class="nv">g</span> : A -&gt; string) (<span class="nv">def</span> : def A) :=
  string_of_name (binder_name (dname def)) ^ <span class="s2">&quot; { struct &quot;</span> ^ string_of_nat (rarg def) ^ <span class="s2">&quot; }&quot;</span> ^
                 <span class="s2">&quot; : &quot;</span> ^ f (dtype def) ^ <span class="s2">&quot; := &quot;</span> ^ nl ^ g (dbody def).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_def</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">tyf</span> <span class="nv">bodyf</span> : A -&gt; B) (<span class="nv">d</span> : def A) :=
  {| dname := d.(dname); dtype := tyf d.(dtype); dbody := bodyf d.(dbody); rarg := d.(rarg) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_dtype</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : A -&gt; B) (<span class="nv">d</span> : def A) :
  f (dtype d) = dtype (map_def f g d).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype d) = dtype (map_def f g d)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype d) = dtype (map_def f g d)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> d; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_dbody</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : A -&gt; B) (<span class="nv">d</span> : def A) :
  g (dbody d) = dbody (map_def f g d).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g (dbody d) = dbody (map_def f g d)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g (dbody d) = dbody (map_def f g d)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> d; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mfixpoint</span> <span class="nv">term</span> := list (def term).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">test_def</span> {<span class="nv">A</span>} (<span class="nv">tyf</span> <span class="nv">bodyf</span> : A -&gt; bool) (<span class="nv">d</span> : def A) :=
  tyf d.(dtype) &amp;&amp; bodyf d.(dbody).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">tFixProp</span> {<span class="nv">A</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">m</span> : mfixpoint A) :=
  All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P x.(dtype) * P&#39; x.(dbody))%type m.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk1f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_def_map_def</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> <span class="nv">f&#39;</span> : B -&gt; C) (<span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B) (<span class="nv">d</span> : def A) :
  map_def f f&#39; (map_def g g&#39; d) = map_def (f ‚àò g) (f&#39; ‚àò g&#39;) d.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; (map_def g g&#39; d) =
map_def (f ‚àò g) (f&#39; ‚àò g&#39;) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk20"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; (map_def g g&#39; d) =
map_def (f ‚àò g) (f&#39; ‚àò g&#39;) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> d; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk21"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">compose_map_def</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> <span class="nv">f&#39;</span> : B -&gt; C) (<span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B) :
  (map_def f f&#39;) ‚àò (map_def g g&#39;) = map_def (f ‚àò g) (f&#39; ‚àò g&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; ‚àò map_def g g&#39; =
map_def (f ‚àò g) (f&#39; ‚àò g&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk22"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; ‚àò map_def g g&#39; =
map_def (f ‚àò g) (f&#39; ‚àò g&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk23"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_def_id</span> {<span class="nv">t</span>} <span class="nv">x</span> : map_def (@id t) (@id t) x = id x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def id id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk24"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def id id x = id x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">destruct</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @map_def_id @map_id : map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_def_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B) (<span class="nv">x</span> : def A) :
  P&#39; x.(dbody) -&gt; P x.(dtype) -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; f x = g x) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, P&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
  map_def f f&#39; x = map_def g g&#39; x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P&#39; (dbody x) -&gt;
P (dtype x) -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : A, P x0 -&gt; f x0 = g x0) -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : A, P&#39; x0 -&gt; f&#39; x0 = g&#39; x0) -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P&#39; (dbody x) -&gt;
P (dtype x) -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : A, P x0 -&gt; f x0 = g x0) -&gt;
(<span class="kr">forall</span> <span class="nv">x0</span> : A, P&#39; x0 -&gt; f&#39; x0 = g&#39; x0) -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk27"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39; (dbody x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P (dtype x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A, P x0 -&gt; f x0 = g x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A, P&#39; x0 -&gt; f&#39; x0 = g&#39; x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk28"><span class="highlight"><span class="nb">destruct</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dname0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dtype0, dbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">rarg0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39;
  (dbody
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P
  (dtype
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39;
  {|
  dname := dname0;
  dtype := dtype0;
  dbody := dbody0;
  rarg := rarg0 |} =
map_def g g&#39;
  {|
  dname := dname0;
  dtype := dtype0;
  dbody := dbody0;
  rarg := rarg0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk29"><span class="highlight"><span class="nb">unfold</span> map_def.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dname0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dtype0, dbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">rarg0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39;
  (dbody
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P
  (dtype
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
dname := dname
           {|
           dname := dname0;
           dtype := dtype0;
           dbody := dbody0;
           rarg := rarg0 |};
dtype := f
           (dtype
              {|
              dname := dname0;
              dtype := dtype0;
              dbody := dbody0;
              rarg := rarg0 |});
dbody := f&#39;
           (dbody
              {|
              dname := dname0;
              dtype := dtype0;
              dbody := dbody0;
              rarg := rarg0 |});
rarg := rarg
          {|
          dname := dname0;
          dtype := dtype0;
          dbody := dbody0;
          rarg := rarg0 |} |} =
{|
dname := dname
           {|
           dname := dname0;
           dtype := dtype0;
           dbody := dbody0;
           rarg := rarg0 |};
dtype := g
           (dtype
              {|
              dname := dname0;
              dtype := dtype0;
              dbody := dbody0;
              rarg := rarg0 |});
dbody := g&#39;
           (dbody
              {|
              dname := dname0;
              dtype := dtype0;
              dbody := dbody0;
              rarg := rarg0 |});
rarg := rarg
          {|
          dname := dname0;
          dtype := dtype0;
          dbody := dbody0;
          rarg := rarg0 |} |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2a"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dname0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">dtype0, dbody0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">rarg0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P&#39;
  (dbody
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P
  (dtype
     {|
     dname := dname0;
     dtype := dtype0;
     dbody := dbody0;
     rarg := rarg0 |})</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
dname := dname0;
dtype := f dtype0;
dbody := f&#39; dbody0;
rarg := rarg0 |} =
{|
dname := dname0;
dtype := g dtype0;
dbody := g&#39; dbody0;
rarg := rarg0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> !H // !H0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">10</span> (_ &lt; _)%nat =&gt; <span class="bp">lia</span> : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">10</span> (_ &lt;= _)%nat =&gt; <span class="bp">lia</span> : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">10</span> (@eq nat _ _) =&gt; <span class="bp">lia</span> : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Extern</span> <span class="mi">0</span> (_ = _) =&gt; <span class="kp">progress</span> <span class="nb">f_equal</span> : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Unfold</span> on_snd snd : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">on_snd_eq_id_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : B -&gt; B) (<span class="nv">x</span> : A * B) :
  f (snd x) = snd x &lt;-&gt;
  on_snd f x = x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A * B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x.<span class="mi">2</span> = x.<span class="mi">2</span> &lt;-&gt; on_snd f x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A * B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x.<span class="mi">2</span> = x.<span class="mi">2</span> &lt;-&gt; on_snd f x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2d"><span class="highlight"><span class="nb">destruct</span> x; <span class="nb">simpl</span>; <span class="nb">unfold</span> on_snd; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f b = b &lt;-&gt; (a, f b) = (a, b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">split</span>; <span class="bp">congruence</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> -&gt; on_snd_eq_id_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> -&gt; on_snd_eq_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_def_eq_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B) (<span class="nv">x</span> : def A) :
  f (dtype x) = g (dtype x) -&gt;
  f&#39; (dbody x) = g&#39; (dbody x) -&gt;
  map_def f f&#39; x = map_def g g&#39; x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype x) = g (dtype x) -&gt;
f&#39; (dbody x) = g&#39; (dbody x) -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk2f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype x) = g (dtype x) -&gt;
f&#39; (dbody x) = g&#39; (dbody x) -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk30"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (dtype x) = g (dtype x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f&#39; (dbody x) = g&#39; (dbody x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> map_def; <span class="nb">f_equal</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_def_eq_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk31"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_def_id_spec</span> {<span class="nv">A</span>} (<span class="nv">f</span> <span class="nv">f&#39;</span> : A -&gt; A) (<span class="nv">x</span> : def A) :
  f (dtype x) = (dtype x) -&gt;
  f&#39; (dbody x) = (dbody x) -&gt;
  map_def f f&#39; x = x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype x) = dtype x -&gt;
f&#39; (dbody x) = dbody x -&gt; map_def f f&#39; x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk32"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (dtype x) = dtype x -&gt;
f&#39; (dbody x) = dbody x -&gt; map_def f f&#39; x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk33"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (dtype x) = dtype x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f&#39; (dbody x) = dbody x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk34"><span class="highlight"><span class="nb">rewrite</span> (map_def_eq_spec _ _ id id); <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f (dtype x) = dtype x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f&#39; (dbody x) = dbody x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def id id x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Resolve</span> map_def_id_spec : <span class="kp">all</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk35"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">tfix_map_spec</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">P</span> <span class="nv">P&#39;</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">l</span>} {<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">g</span> <span class="nv">g&#39;</span> : A -&gt; B} :
  tFixProp P P&#39; l -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; f x = g x) -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span>, P&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
  map (map_def f f&#39;) l = map (map_def g g&#39;) l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tFixProp P P&#39; l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tFixProp P P&#39; l -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x) -&gt;
map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk37"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tFixProp P P&#39; l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (map_def f f&#39;) l = map (map_def g g&#39;) l</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk38"><span class="highlight"><span class="nb">eapply</span> All_map_eq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tFixProp P P&#39; l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; map_def f f&#39; x = map_def g g&#39; x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk39"><span class="highlight"><span class="nb">red</span> <span class="kr">in</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; map_def f f&#39; x = map_def g g&#39; x)
  l</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3a"><span class="highlight"><span class="nb">eapply</span> All_impl; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
(<span class="kr">fun</span> <span class="nv">x0</span> : def A =&gt; P (dtype x0) * P&#39; (dbody x0)) x -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3b"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All (<span class="kr">fun</span> <span class="nv">x</span> : def A =&gt; P (dtype x) * P&#39; (dbody x))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P&#39; x -&gt; f&#39; x = g&#39; x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : def A,
P (dtype x) √ó P&#39; (dbody x) -&gt;
map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3c"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P, P'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mfixpoint A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, f', g, g'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">All
  (<span class="kr">fun</span> <span class="nv">x0</span> : def A =&gt; P (dtype x0) * P&#39; (dbody x0))
  l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A, P x0 -&gt; f x0 = g x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : A, P&#39; x0 -&gt; f&#39; x0 = g&#39; x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">def A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P (dtype x) * P&#39; (dbody x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_def f f&#39; x = map_def g g&#39; x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> X0;
  <span class="nb">eapply</span> map_def_spec; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Contexts</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> : <span class="kt">Type</span>}.</span></span></span></pre><div class="doc">
<a name="lab2"></a><h3 class="section">The context of De Bruijn indices</h3>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">context_decl</span> := mkdecl {
    decl_name : aname ;
    decl_body : option term ;
    decl_type : term
  }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Derive</span> <span class="nf">NoConfusion</span> <span class="kr">for</span> context_decl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Contexts</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> context_decl : <span class="kn">clear implicits</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_decl</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} (<span class="nv">f</span> : term -&gt; term&#39;) (<span class="nv">d</span> : context_decl term) : context_decl term&#39; :=
  {| decl_name := d.(decl_name);
     decl_body := option_map f d.(decl_body);
     decl_type := f d.(decl_type) |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">compose_map_decl</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span>} (<span class="nv">g</span> : term -&gt; term&#39;) (<span class="nv">f</span> : term&#39; -&gt; term&#39;&#39;) <span class="nv">x</span> :
  map_decl f (map_decl g x) = map_decl (f ‚àò g) x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl f (map_decl g x) = map_decl (f ‚àò g) x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term&#39; -&gt; term&#39;&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl f (map_decl g x) = map_decl (f ‚àò g) x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x <span class="kr">as</span> [? [?|] ?]; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">   
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk3f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_decl_ext</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} (<span class="nv">f</span> <span class="nv">g</span> : term -&gt; term&#39;) <span class="nv">x</span> : (<span class="kr">forall</span> <span class="nv">x</span>, f x = g x) -&gt; map_decl f x = map_decl g x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 = g x0) -&gt;
map_decl f x = map_decl g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk40"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 = g x0) -&gt;
map_decl f x = map_decl g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk41"><span class="highlight"><span class="nb">intros</span> H; <span class="nb">destruct</span> x <span class="kr">as</span> [? [?|] ?]; <span class="nb">rewrite</span> /map_decl /=; <span class="nb">f_equal</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t, decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : term, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (f t) = Some (g t)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> (H t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk42"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_decl_proper</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@map_decl term term&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk43"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk44"><span class="highlight"><span class="nb">intros</span> f g Hfg x y -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl f y = map_decl g y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">apply</span> map_decl_ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk45"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_decl_pointwise</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} : Proper (`=<span class="mi">1</span>` ==&gt; `=<span class="mi">1</span>`) (@map_decl term term&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; (`=<span class="mi">1</span>`)) map_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk46"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; (`=<span class="mi">1</span>`)) map_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk47"><span class="highlight"><span class="nb">intros</span> f g Hfg x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl f x = map_decl g x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk48"><span class="highlight"><span class="nb">rewrite</span> /map_decl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
decl_name := decl_name x;
decl_body := option_map f (decl_body x);
decl_type := f (decl_type x) |} =
{|
decl_name := decl_name x;
decl_body := option_map g (decl_body x);
decl_type := g (decl_type x) |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk49"><span class="highlight"><span class="nb">destruct</span> x =&gt; /=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
decl_name := decl_name0;
decl_body := option_map f decl_body0;
decl_type := f decl_type0 |} =
{|
decl_name := decl_name0;
decl_body := option_map g decl_body0;
decl_type := g decl_type0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4a"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map f decl_body0 = option_map g decl_body0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk4b"><hr></label><div class="goal-conclusion"><span class="highlight">f decl_type0 = g decl_type0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4c"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map f decl_body0 = option_map g decl_body0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4d"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_name0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">aname</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_body0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl_type0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f decl_type0 = g decl_type0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(*</span>

<span class="c">Instance pointwise_subrelation {A B} : subrelation (`=1`) (@Logic.eq A ==&gt; @Logic.eq B)%signature.</span>
<span class="c">Proof.</span>
<span class="c">  intros f g Hfg x y -&gt;. now rewrite Hfg.</span>
<span class="c">Qed.</span>

<span class="c">Instance pointwise_subrelation_inv {A B} : subrelation (@Logic.eq A ==&gt; @Logic.eq B)%signature  (`=1`).</span>
<span class="c">Proof.</span>
<span class="c">  intros f g Hfg x. now specialize (Hfg x x eq_refl).</span>
<span class="c">Qed.*)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} (<span class="nv">f</span> : term -&gt; term&#39;) (<span class="nv">c</span> : list (context_decl term)) :=
  List.map (map_decl f) c.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4e"><span class="highlight"><span class="kn">Instance</span> <span class="nf">map_context_proper</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@map_context term term&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_context</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) map_context</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk50"><span class="highlight"><span class="nb">intros</span> f g Hfg x y -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_context f y = map_context g y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> /map_context Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk51"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_context_length</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} (<span class="nv">f</span> : term -&gt; term&#39;) <span class="nv">l</span> : #|map_context f l| = #|l|.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|map_context f l| = #|l|</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk52"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|map_context f l| = #|l|</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">unfold</span> map_context; <span class="nb">rewrite</span> map_length.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @map_context_length : len.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">test_decl</span> {<span class="nv">term</span>} (<span class="nv">f</span> : term -&gt; bool) (<span class="nv">d</span> : context_decl term) : bool :=
  option_default f d.(decl_body) true &amp;&amp; f d.(decl_type).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk53"><span class="highlight"><span class="kn">Instance</span> <span class="nf">test_decl_proper</span> {<span class="nv">term</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@test_decl term).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) test_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk54"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) test_decl</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> f g Hfg [na [b|] ty] ? &lt;- =&gt; /=; <span class="nb">rewrite</span> /test_decl /=;
  <span class="bp">now</span> <span class="nb">rewrite</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">snoc</span> {<span class="nv">A</span>} (<span class="nv">Œì</span> : list A) (<span class="nv">d</span> : A) := d :: Œì.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; Œì ,, d &quot;</span> := (snoc Œì d) (<span class="kn">at level</span> <span class="mi">20</span>, d <span class="kn">at next level</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ContextMap</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : nat -&gt; term -&gt; term&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">mapi_context</span> (<span class="nv">c</span> : list (context_decl term)) : list (context_decl term&#39;) :=
    <span class="kr">match</span> c <span class="kr">with</span>
    | d :: Œì =&gt; map_decl (f #|Œì|) d :: mapi_context Œì
    | [] =&gt; []
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ContextMap</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk55"><span class="highlight"><span class="kn">Instance</span> <span class="nf">mapi_context_proper</span> {<span class="nv">term</span> <span class="nv">term&#39;</span>} : Proper (`=<span class="mi">2</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@mapi_context term term&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">2</span>`) ==&gt; eq ==&gt; eq) mapi_context</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk56"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">2</span>`) ==&gt; eq ==&gt; eq) mapi_context</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk57"><span class="highlight"><span class="nb">intros</span> f g Hfg Œì ? &lt;-.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">2</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context f Œì = mapi_context g Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> Œì <span class="kr">as</span> [|[na [b|] ty] Œì]; <span class="nb">simpl</span>; <span class="nb">auto</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>; <span class="bp">now</span> <span class="nb">rewrite</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk58"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mapi_context_length</span> {<span class="nv">term</span>} (<span class="nv">f</span> : nat -&gt; term -&gt; term) <span class="nv">l</span> : #|mapi_context f l| = #|l|.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|mapi_context f l| = #|l|</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|mapi_context f l| = #|l|</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> l; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">  
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hint Rewrite</span> @mapi_context_length : len.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ContextTest</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : term -&gt; bool).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">test_context</span> (<span class="nv">c</span> : list (context_decl term)) : bool :=
    <span class="kr">match</span> c <span class="kr">with</span>
    | d :: Œì =&gt; test_context Œì &amp;&amp; test_decl f d
    | [] =&gt; true
    <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ContextTest</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">test_context_proper</span> {<span class="nv">term</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq) (@test_context term).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) test_context</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq) test_context</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5c"><span class="highlight"><span class="nb">intros</span> f g Hfg Œì ? &lt;-.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">test_context f Œì = test_context g Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> Œì <span class="kr">as</span> [|[na [b|] ty] Œì]; <span class="nb">simpl</span>; <span class="nb">auto</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>; <span class="bp">now</span> <span class="nb">rewrite</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ContextTestK</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : nat -&gt; term -&gt; bool) (<span class="nv">k</span> : nat).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">test_context_k</span> (<span class="nv">c</span> : list (context_decl term)) : bool :=
    <span class="kr">match</span> c <span class="kr">with</span>
    | d :: Œì =&gt; test_context_k Œì &amp;&amp; test_decl (f (#|Œì| + k)) d
    | [] =&gt; true
    <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ContextTestK</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5d"><span class="highlight"><span class="kn">Instance</span> <span class="nf">test_context_k_proper</span> {<span class="nv">term</span>} : Proper (`=<span class="mi">1</span>` ==&gt; Logic.eq ==&gt; Logic.eq ==&gt; Logic.eq) (@test_context_k term).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq ==&gt; eq) test_context_k</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Proper ((`=<span class="mi">1</span>`) ==&gt; eq ==&gt; eq ==&gt; eq) test_context_k</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk5f"><span class="highlight"><span class="nb">intros</span> f g Hfg k ? &lt;- Œì ? &lt;-.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hfg</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f =<span class="mi">1</span> g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">test_context_k f k Œì = test_context_k g k Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> Œì <span class="kr">as</span> [|[na [b|] ty] Œì]; <span class="nb">simpl</span>; <span class="nb">auto</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>; <span class="bp">now</span> <span class="nb">rewrite</span> Hfg.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Contexts</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span> : <span class="kt">Type</span>}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk60"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_decl_impl</span> (<span class="nv">f</span> <span class="nv">g</span> : term -&gt; bool) <span class="nv">x</span> : (<span class="kr">forall</span> <span class="nv">x</span>, f x -&gt; g x) -&gt; 
    test_decl f x -&gt; test_decl g x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 -&gt; g x0) -&gt;
test_decl f x -&gt; test_decl g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk61"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 -&gt; g x0) -&gt;
test_decl f x -&gt; test_decl g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk62"><span class="highlight"><span class="nb">intros</span> Hf; <span class="nb">rewrite</span> /test_decl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 -&gt; g x0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_default f (decl_body x) true &amp;&amp; f (decl_type x) -&gt;
option_default g (decl_body x) true &amp;&amp; g (decl_type x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk63"><span class="highlight"><span class="nb">move</span>/andb_and=&gt; [Hd Hb].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 -&gt; g x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (option_default f (decl_body x) true)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (f (decl_type x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true
  (option_default g (decl_body x) true &amp;&amp;
   g (decl_type x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk64"><span class="highlight"><span class="nb">apply</span>/andb_and; <span class="nb">split</span>; <span class="nb">eauto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hf</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : term, f x0 -&gt; g x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hd</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (option_default f (decl_body x) true)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (f (decl_type x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (option_default g (decl_body x) true)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (decl_body x); <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">eauto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk65"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_decl_type</span> (<span class="nv">f</span> : term -&gt; term&#39;) <span class="nv">decl</span> : f (decl_type decl) = decl_type (map_decl f decl).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (decl_type decl) = decl_type (map_decl f decl)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk66"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (decl_type decl) = decl_type (map_decl f decl)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> decl; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk67"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_decl_body</span> (<span class="nv">f</span> : term -&gt; term&#39;) <span class="nv">decl</span> : option_map f (decl_body decl) = decl_body (map_decl f decl).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map f (decl_body decl) =
decl_body (map_decl f decl)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk68"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">decl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map f (decl_body decl) =
decl_body (map_decl f decl)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> decl; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk69"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">map_decl_id</span> : @map_decl term term id =<span class="mi">1</span> id.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl id =<span class="mi">1</span> id</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl id =<span class="mi">1</span> id</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> d; <span class="bp">now</span> <span class="nb">destruct</span> d <span class="kr">as</span> [? [] ?].</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">option_map_decl_body_map_decl</span> (<span class="nv">f</span> : term -&gt; term&#39;) <span class="nv">x</span> :
    option_map decl_body (option_map (map_decl f) x) =
    option_map (option_map f) (option_map decl_body x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map decl_body (option_map (map_decl f) x) =
option_map (option_map f) (option_map decl_body x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map decl_body (option_map (map_decl f) x) =
option_map (option_map f) (option_map decl_body x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">option_map_decl_type_map_decl</span> (<span class="nv">f</span> : term -&gt; term&#39;) <span class="nv">x</span> :
    option_map decl_type (option_map (map_decl f) x) =
    option_map f (option_map decl_type x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map decl_type (option_map (map_decl f) x) =
option_map f (option_map decl_type x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">option_map decl_type (option_map (map_decl f) x) =
option_map f (option_map decl_type x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fold_context_k</span> (<span class="nv">f</span> : nat -&gt; term -&gt; term&#39;) <span class="nv">Œì</span> :=
    List.rev (mapi (<span class="kr">fun</span> <span class="nv">k&#39;</span> <span class="nv">decl</span> =&gt; map_decl (f k&#39;) decl) (List.rev Œì)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> fold_context_k f Œì%list_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk6f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fold_context_k_alt</span> <span class="nv">f</span> <span class="nv">Œì</span> :
    fold_context_k f Œì =
    mapi (<span class="kr">fun</span> <span class="nv">k&#39;</span> <span class="nv">d</span> =&gt; map_decl (f (Nat.pred (length Œì) - k&#39;)) d) Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f Œì =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk70"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f Œì =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk71"><span class="highlight"><span class="nb">unfold</span> fold_context_k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì)) =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk72"><span class="highlight"><span class="nb">rewrite</span> rev_mapi.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x)
  (List.rev (List.rev Œì)) =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk73"><span class="highlight"><span class="nb">rewrite</span> List.rev_involutive.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk74"><span class="highlight"><span class="nb">apply</span> mapi_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term),
map_decl (f (Nat.pred #|List.rev Œì| - n)) x =
map_decl (f (Nat.pred #|Œì| - n)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk75"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|List.rev Œì| - n)) x =
map_decl (f (Nat.pred #|Œì| - n)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk76"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (Nat.pred #|List.rev Œì| - n) = f (Nat.pred #|Œì| - n)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> List.rev_length.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk77"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mapi_context_fold</span> <span class="nv">f</span> <span class="nv">Œì</span> :
    mapi_context f Œì = fold_context_k f Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context f Œì = fold_context_k f Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk78"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context f Œì = fold_context_k f Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk79"><span class="highlight"><span class="nb">setoid_replace</span> f <span class="kr">with</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f (k - <span class="mi">0</span>)) <span class="nb">using relation</span> 
      (pointwise_relation nat (pointwise_relation term (@Logic.eq term&#39;)))%signature <span class="nb">at</span> <span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>)) Œì =
fold_context_k f Œì</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk7b"><span class="highlight"><span class="nb">rewrite</span> fold_context_k_alt.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>)) Œì =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk7c"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk7d"><span class="highlight"><span class="nb">unfold</span> mapi.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì <span class="mi">0</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk7e"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk7f"><span class="highlight"><span class="nb">generalize</span> <span class="mi">0</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d) Œì n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk80"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk81"><span class="highlight"><span class="nb">induction</span> Œì <span class="kr">as</span> [|d Œì]; <span class="nb">intros</span> n; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (#|Œì| - n)) d
:: mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n)) Œì =
map_decl (f (#|Œì| - n)) d
:: mapi_rec
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
      map_decl (f (#|Œì| - k&#39;)) d0) Œì (S n)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk82"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk83"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (#|Œì| - k&#39;)) d0) Œì (S n)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk84"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk85"><span class="highlight"><span class="nb">rewrite</span> IHŒì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (#|Œì| - k&#39;)) d0) Œì (S n)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk86"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk87"><span class="highlight"><span class="nb">rewrite</span> mapi_rec_Sk.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (#|Œì| - S n0)) x) Œì n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk88"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk89"><span class="highlight"><span class="nb">apply</span> mapi_rec_ext =&gt; k x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; f (k0 - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n &lt;= k -&gt;
k &lt; #|Œì| + n -&gt;
map_decl (f (Nat.pred #|Œì| - k)) x =
map_decl (f (#|Œì| - S k)) x</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk8b"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; f (k0 - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|Œì| - k)) x =
map_decl (f (#|Œì| - S k)) x</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk8c"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk8d"><span class="highlight"><span class="nb">apply</span> map_decl_ext =&gt; t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHŒì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : nat,
mapi_context (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; f (k0 - n0)) Œì =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">d0</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|Œì| - k&#39;)) d0) Œì n0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (Nat.pred #|Œì| - k) t = f (#|Œì| - S k) t</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk8e"><hr></label><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk8f"><span class="highlight">lia_f_equal.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f =<span class="mi">2</span> (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (k - <span class="mi">0</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk90"><span class="highlight"><span class="nb">intros</span> k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f k =<span class="mi">1</span> f (k - <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> Nat.sub_0_r.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk91"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fold_context_k_tip</span> <span class="nv">f</span> <span class="nv">d</span> : fold_context_k f [d] = [map_decl (f <span class="mi">0</span>) d].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f [d] = [map_decl (f <span class="mi">0</span>) d]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk92"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f [d] = [map_decl (f <span class="mi">0</span>) d]</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk93"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fold_context_k_length</span> <span class="nv">f</span> <span class="nv">Œì</span> : length (fold_context_k f Œì) = length Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|fold_context_k f Œì| = #|Œì|</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk94"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|fold_context_k f Œì| = #|Œì|</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk95"><span class="highlight"><span class="nb">unfold</span> fold_context_k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">#|List.rev
    (mapi
       (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
        map_decl (f k&#39;) decl) (List.rev Œì))| = #|Œì|</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> !List.rev_length mapi_length List.rev_length.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk96"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fold_context_k_snoc0</span> <span class="nv">f</span> <span class="nv">Œì</span> <span class="nv">d</span> :
    fold_context_k f (d :: Œì) = fold_context_k f Œì ,, map_decl (f (length Œì)) d.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f (d :: Œì) =
fold_context_k f Œì,, map_decl (f #|Œì|) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk97"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f (d :: Œì) =
fold_context_k f Œì,, map_decl (f #|Œì|) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk98"><span class="highlight"><span class="nb">unfold</span> fold_context_k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev (d :: Œì))) =
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì)),,
map_decl (f #|Œì|) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk99"><span class="highlight"><span class="nb">rewrite</span> !rev_mapi !rev_involutive.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev (d :: Œì)| - k)) x)
  (d :: Œì) =
mapi
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì,,
map_decl (f #|Œì|) d</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk9a"><span class="highlight"><span class="nb">unfold</span> mapi; <span class="nb">rewrite</span> mapi_rec_eqn.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|List.rev (d :: Œì)| - <span class="mi">0</span>)) d
:: mapi_rec
     (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
      map_decl (f (Nat.pred #|List.rev (d :: Œì)| - k))
        x) Œì <span class="mi">1</span> =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span>,,
map_decl (f #|Œì|) d</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk9b"><span class="highlight"><span class="nb">unfold</span> snoc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|List.rev (d :: Œì)| - <span class="mi">0</span>)) d
:: mapi_rec
     (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
      map_decl (f (Nat.pred #|List.rev (d :: Œì)| - k))
        x) Œì <span class="mi">1</span> =
map_decl (f #|Œì|) d
:: mapi_rec
     (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
      map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk9c"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|List.rev (d :: Œì)| - <span class="mi">0</span>)) d =
map_decl (f #|Œì|) d</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="BasicAst-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="BasicAst-v-chk9d"><hr></label><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev (d :: Œì)| - k)) x)
  Œì <span class="mi">1</span> =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk9e"><span class="highlight"><span class="bp">now</span> <span class="nb">rewrite</span> Nat.sub_0_r List.rev_length.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev (d :: Œì)| - k)) x)
  Œì <span class="mi">1</span> =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chk9f"><span class="highlight"><span class="nb">rewrite</span> mapi_rec_Sk.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev (d :: Œì)| - S n))
     x) Œì <span class="mi">0</span> =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka0"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi_rec
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì ++ [d]| - S n))
     x) Œì <span class="mi">0</span> =
mapi_rec
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (Nat.pred #|List.rev Œì| - k)) x) Œì <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka1"><span class="highlight"><span class="nb">apply</span> mapi_rec_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">x</span> : context_decl term),
<span class="mi">0</span> &lt;= k -&gt;
k &lt; #|Œì| + <span class="mi">0</span> -&gt;
map_decl (f (Nat.pred #|List.rev Œì ++ [d]| - S k)) x =
map_decl (f (Nat.pred #|List.rev Œì| - k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka2"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred #|List.rev Œì ++ [d]| - S k)) x =
map_decl (f (Nat.pred #|List.rev Œì| - k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka3"><span class="highlight"><span class="nb">rewrite</span> app_length !List.rev_length.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred (#|Œì| + #|[d]|) - S k)) x =
map_decl (f (Nat.pred #|Œì| - k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka4"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (Nat.pred (#|Œì| + <span class="mi">1</span>) - S k)) x =
map_decl (f (Nat.pred #|Œì| - k)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka5"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (Nat.pred (#|Œì| + <span class="mi">1</span>) - S k) = f (Nat.pred #|Œì| - k)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka6"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k &lt; #|Œì| + <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Nat.pred (#|Œì| + <span class="mi">1</span>) - S k = Nat.pred #|Œì| - k</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fold_context_k_app</span> <span class="nv">f</span> <span class="nv">Œì</span> <span class="nv">Œî</span> :
    fold_context_k f (Œî ++ Œì)
    = fold_context_k (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f (length Œì + k)) Œî ++ fold_context_k f Œì.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f (Œî ++ Œì) =
fold_context_k (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (#|Œì| + k)) Œî ++
fold_context_k f Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_context_k f (Œî ++ Œì) =
fold_context_k (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; f (#|Œì| + k)) Œî ++
fold_context_k f Œì</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chka9"><span class="highlight"><span class="nb">unfold</span> fold_context_k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev (Œî ++ Œì))) =
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî)) ++
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkaa"><span class="highlight"><span class="nb">rewrite</span> List.rev_app_distr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì ++ List.rev Œî)) =
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî)) ++
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkab"><span class="highlight"><span class="nb">rewrite</span> mapi_app.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì) ++
   mapi
     (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
      map_decl (f (#|List.rev Œì| + n)) x) (List.rev Œî)) =
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî)) ++
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkac"><span class="highlight"><span class="nb">rewrite</span> &lt;- List.rev_app_distr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì) ++
   mapi
     (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
      map_decl (f (#|List.rev Œì| + n)) x) (List.rev Œî)) =
List.rev
  (mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f k&#39;) decl) (List.rev Œì) ++
   mapi
     (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
      map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkad"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
   map_decl (f k&#39;) decl) (List.rev Œì) ++
mapi
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (#|List.rev Œì| + n)) x) (List.rev Œî) =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
   map_decl (f k&#39;) decl) (List.rev Œì) ++
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
   map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkae"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mapi
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term) =&gt;
   map_decl (f (#|List.rev Œì| + n)) x) (List.rev Œî) =
mapi
  (<span class="kr">fun</span> (<span class="nv">k&#39;</span> : nat) (<span class="nv">decl</span> : context_decl term) =&gt;
   map_decl (f (#|Œì| + k&#39;)) decl) (List.rev Œî)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkaf"><span class="highlight"><span class="nb">apply</span> mapi_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : context_decl term),
map_decl (f (#|List.rev Œì| + n)) x =
map_decl (f (#|Œì| + n)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkb0"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_decl (f (#|List.rev Œì| + n)) x =
map_decl (f (#|Œì| + n)) x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkb1"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (#|List.rev Œì| + n) = f (#|Œì| + n)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkb2"><span class="highlight"><span class="nb">rewrite</span> List.rev_length.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">term, term', term''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat -&gt; term -&gt; term&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Œì, Œî</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (context_decl term)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">context_decl term</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (#|Œì| + n) = f (#|Œì| + n)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
This function allows to forget type annotations on a binding context. 
  Useful to relate the "compact" case representation in terms, with 
  its typing relation, where the context has types 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="BasicAst-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="BasicAst-v-chkb3"><span class="highlight"><span class="kn">Definition</span> <span class="nf">forget_types</span> (<span class="nv">c</span> : list (BasicAst.context_decl term)) : list aname := 
    map decl_name c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The reference BasicAst.context_decl was not found
<span class="kr">in</span> the current environment.</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  
<span class="kn">End</span> <span class="nf">Contexts</span>.
<span class="kn">Hint Rewrite</span> @fold_context_k_length : len.

<span class="kn">Section</span> <span class="nf">Contexts</span>.
  <span class="kn">Context</span> {<span class="nv">term</span> <span class="nv">term&#39;</span> <span class="nv">term&#39;&#39;</span> : <span class="kt">Type</span>}.
  <span class="kn">Notation</span> <span class="nf">context</span> term := (list (context_decl term)).

  <span class="kn">Lemma</span> <span class="nf">fold_context_k_id</span> (<span class="nv">x</span> : <span class="kp">context</span> term) : fold_context_k (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> =&gt; x) x = x.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> fold_context_k_alt.
    <span class="nb">rewrite</span> /mapi. <span class="nb">generalize</span> <span class="mi">0</span>.
    <span class="nb">induction</span> x; <span class="nb">simpl</span>; <span class="nb">auto</span>.
    <span class="nb">intros</span> n.
    <span class="nb">f_equal</span>; <span class="nb">auto</span>. 
    <span class="bp">now</span> <span class="nb">rewrite</span> map_decl_id.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">fold_context_k_compose</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) (<span class="nv">g</span> : nat -&gt; term&#39;&#39; -&gt; term&#39;) <span class="nv">Œì</span> : 
    fold_context_k f (fold_context_k g Œì) = 
    fold_context_k (<span class="kr">fun</span> <span class="nv">i</span> =&gt; f i ‚àò g i) Œì.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> !fold_context_k_alt mapi_mapi.
    <span class="nb">apply</span> mapi_ext =&gt; i d.
    <span class="nb">rewrite</span> compose_map_decl. <span class="nb">apply</span> map_decl_ext =&gt; t.
    <span class="bp">now</span> len.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">fold_context_k_ext</span> (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; term&#39; -&gt; term) <span class="nv">Œì</span> :
    f =<span class="mi">2</span> g -&gt;
    fold_context_k f Œì = fold_context_k g Œì.
  <span class="kn">Proof</span>.
    <span class="nb">intros</span> hfg.
    <span class="nb">induction</span> Œì; <span class="nb">simpl</span>; <span class="nb">auto</span>; <span class="nb">rewrite</span> !fold_context_k_snoc0.
    <span class="nb">simpl</span>. <span class="nb">rewrite</span> IHŒì. <span class="nb">f_equal</span>. <span class="nb">apply</span> map_decl_ext.
    <span class="nb">intros</span>. <span class="bp">now</span> <span class="nb">apply</span> hfg.
  <span class="kn">Qed</span>.

  #[<span class="kn">global</span>] 
  <span class="kn">Instance</span> <span class="nf">fold_context_k_proper</span> : Proper (pointwise_relation nat (pointwise_relation _ Logic.eq) ==&gt; Logic.eq ==&gt; Logic.eq) 
    (@fold_context_k term&#39; term).
  <span class="kn">Proof</span>.
    <span class="nb">intros</span> f g Hfg x y &lt;-. <span class="bp">now</span> <span class="nb">apply</span> fold_context_k_ext.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">alli_fold_context_k_prop</span> (<span class="nv">f</span> : nat -&gt; context_decl term -&gt; bool) (<span class="nv">g</span> : nat -&gt; term&#39; -&gt; term) <span class="nv">ctx</span> : 
    alli f <span class="mi">0</span> (fold_context_k g ctx) =
    alli (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">x</span> =&gt; f i (map_decl (g (Nat.pred #|ctx| - i)) x)) <span class="mi">0</span> ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> fold_context_k_alt /mapi alli_mapi.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">test_decl_map_decl</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">x</span> : (@test_decl term) f (map_decl g x) = @test_decl term (f ‚àò g) x.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> /test_decl /map_decl /=.
    <span class="nb">f_equal</span>. <span class="nb">rewrite</span> /option_default.
    <span class="nb">destruct</span> (decl_body x) =&gt; //.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">map_fold_context_k</span> (<span class="nv">f</span> : term&#39; -&gt; term) (<span class="nv">g</span> : nat -&gt; term&#39;&#39; -&gt; term&#39;) <span class="nv">ctx</span> : 
    map (map_decl f) (fold_context_k g ctx) = fold_context_k (<span class="kr">fun</span> <span class="nv">i</span> =&gt; f ‚àò g i) ctx.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> !fold_context_k_alt map_mapi. 
    <span class="nb">apply</span> mapi_ext =&gt; i d. <span class="bp">now</span> <span class="nb">rewrite</span> compose_map_decl.
  <span class="kn">Qed</span>.
 
  <span class="kn">Lemma</span> <span class="nf">map_context_mapi_context</span> (<span class="nv">f</span> : term&#39; -&gt; term) (<span class="nv">g</span> : nat -&gt; term&#39;&#39; -&gt; term&#39;) (<span class="nv">ctx</span> : list (BasicAst.context_decl term&#39;&#39;)) :
    map_context f (mapi_context g ctx) = 
    mapi_context (<span class="kr">fun</span> <span class="nv">i</span> =&gt; f ‚àò g i) ctx.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> !mapi_context_fold. <span class="bp">now</span> <span class="nb">unfold</span> map_context; <span class="nb">rewrite</span> map_fold_context_k.
  <span class="kn">Qed</span>.
  
  <span class="kn">Lemma</span> <span class="nf">mapi_context_map</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) (<span class="nv">g</span> : context_decl term&#39;&#39; -&gt; context_decl term&#39;) <span class="nv">ctx</span> :
    mapi_context f (map g ctx) = mapi (<span class="kr">fun</span> <span class="nv">i</span> =&gt; map_decl (f (Nat.pred #|ctx| - i)) ‚àò g) ctx.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> mapi_context_fold fold_context_k_alt mapi_map. <span class="bp">now</span> len.
  <span class="kn">Qed</span>.
   
  <span class="kn">Lemma</span> <span class="nf">map_context_map</span> (<span class="nv">f</span> : term&#39; -&gt; term) (<span class="nv">g</span> : context_decl term&#39;&#39; -&gt; context_decl term&#39;) <span class="nv">ctx</span> :
    map_context f (map g ctx) = map (map_decl f ‚àò g) ctx.
  <span class="kn">Proof</span>.
    <span class="nb">induction</span> ctx; <span class="nb">simpl</span>; <span class="nb">f_equal</span>; <span class="nb">auto</span>.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">map_map_context</span> (<span class="nv">f</span> : context_decl term&#39; -&gt; term) (<span class="nv">g</span> : term&#39;&#39; -&gt; term&#39;) <span class="nv">ctx</span> :
    map f (map_context g ctx) = map (f ‚àò map_decl g) ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> /map_context map_map_compose.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">fold_context_k_map</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) (<span class="nv">g</span> : term&#39;&#39; -&gt; term&#39;) <span class="nv">Œì</span> : 
    fold_context_k f (map_context g Œì) = 
    fold_context_k (<span class="kr">fun</span> <span class="nv">k</span> =&gt; f k ‚àò g) Œì.
  <span class="kn">Proof</span>.
    <span class="nb">rewrite</span> !fold_context_k_alt mapi_map.
    <span class="nb">apply</span> mapi_ext =&gt; n d //. len.
    <span class="bp">now</span> <span class="nb">rewrite</span> compose_map_decl.
  <span class="kn">Qed</span>.
  
  <span class="kn">Lemma</span> <span class="nf">fold_context_k_map_comm</span> (<span class="nv">f</span> : nat -&gt; term -&gt; term) (<span class="nv">g</span> : term -&gt; term) <span class="nv">Œì</span> : 
    (<span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, f i (g x) = g (f i x)) -&gt;
    fold_context_k f (map_context g Œì) = map_context g (fold_context_k f Œì).
  <span class="kn">Proof</span>.
    <span class="nb">intros</span> Hfg.
    <span class="nb">rewrite</span> !fold_context_k_alt mapi_map.
    <span class="nb">rewrite</span> /map_context map_mapi.
    <span class="nb">apply</span> mapi_ext =&gt; i x.
    <span class="nb">rewrite</span> !compose_map_decl.
    <span class="nb">apply</span> map_decl_ext =&gt; t.
    <span class="nb">rewrite</span> Hfg.
    <span class="bp">now</span> len.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">mapi_context_map_context</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) (<span class="nv">g</span> : term&#39;&#39; -&gt; term&#39;) <span class="nv">ctx</span> :
    mapi_context f (map_context g ctx) = 
    mapi_context (<span class="kr">fun</span> <span class="nv">i</span> =&gt; f i ‚àò g) ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> !mapi_context_fold fold_context_k_map.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">map_mapi_context</span> (<span class="nv">f</span> : context_decl term&#39; -&gt; term) (<span class="nv">g</span> : nat -&gt; term&#39;&#39; -&gt; term&#39;) <span class="nv">ctx</span> :
    map f (mapi_context g ctx) = mapi (<span class="kr">fun</span> <span class="nv">i</span> =&gt; f ‚àò map_decl (g (Nat.pred #|ctx| - i))) ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> mapi_context_fold fold_context_k_alt map_mapi.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">map_context_id</span> (<span class="nv">ctx</span> : <span class="kp">context</span> term) : map_context id ctx = ctx.
  <span class="kn">Proof</span>.
    <span class="nb">unfold</span> map_context.
    <span class="bp">now</span> <span class="nb">rewrite</span> map_decl_id map_id.
  <span class="kn">Qed</span>.
    
  <span class="kn">Lemma</span> <span class="nf">forget_types_length</span> (<span class="nv">ctx</span> : list (BasicAst.context_decl term)) :
    #|forget_types ctx| = #|ctx|.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> /forget_types map_length.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">map_decl_name_fold_context_k</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) <span class="nv">ctx</span> : 
    map decl_name (fold_context_k f ctx) = map decl_name ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> fold_context_k_alt map_mapi /= mapi_cst_map.
  <span class="kn">Qed</span>.

  <span class="kn">Lemma</span> <span class="nf">forget_types_fold_context_k</span> (<span class="nv">f</span> : nat -&gt; term&#39; -&gt; term) <span class="nv">ctx</span> : 
    forget_types (fold_context_k f ctx) = forget_types ctx.
  <span class="kn">Proof</span>.
    <span class="bp">now</span> <span class="nb">rewrite</span> /forget_types map_decl_name_fold_context_k.
  <span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Contexts</span>.

<span class="kn">Hint Rewrite</span> @map_mapi_context
  @map_fold_context_k @mapi_context_map @map_context_map @map_map_context 
  @mapi_context_map_context @map_context_mapi_context : map.
<span class="kn">Hint Rewrite</span> @forget_types_length : len.</span></span></pre><div class="doc">
Primitive types models (axiom free) 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --></pre><div class="doc">
Model of unsigned integers 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="kn">Definition</span> <span class="nf">uint_size</span> := <span class="mi">63</span>.
<span class="kn">Definition</span> <span class="nf">uint_wB</span> := (<span class="mi">2</span> ^ (Z.of_nat uint_size))%Z.
<span class="kn">Definition</span> <span class="nf">uint63_model</span> := { z : Z | ((<span class="mi">0</span> &lt;=? z) &amp;&amp; (z &lt;? uint_wB))%Z }.

<span class="kn">Definition</span> <span class="nf">string_of_uint63_model</span> (<span class="nv">i</span> : uint63_model) := string_of_Z (proj1_sig i).</span></span></pre><div class="doc">
Model of floats 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="kn">Definition</span> <span class="nf">prec</span> := <span class="mi">53</span>%Z.
<span class="kn">Definition</span> <span class="nf">emax</span> := <span class="mi">1024</span>%Z.</span></span></pre><div class="doc">
We consider valid binary encordings of floats as our model 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="kn">Definition</span> <span class="nf">float64_model</span> := sig (SpecFloat.valid_binary prec emax).

<span class="kn">Definition</span> <span class="nf">string_of_float64_model</span> (<span class="nv">i</span> : float64_model) := 
  <span class="s2">&quot;&lt;float&gt;&quot;</span>.</span></span></pre></article></body></html>